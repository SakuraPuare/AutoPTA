{
    "1767420176117731328": {
        "problemSetProblemId": "1767420176117731328",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "\n"
        },
        "problemId": "0"
    },
    "1767420176117731329": {
        "problemSetProblemId": "1767420176117731329",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "Hello World!"
        },
        "problemId": "0"
    },
    "1767420176117731330": {
        "problemSetProblemId": "1767420176117731330",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(){\n\tint n=0;\n\tstring s;\n\tcin >> n>> s;\n\tif(n==0){\n\t\tprintf(\"0\");\n\t\treturn 0;\n\t} \n\tint i=0;\n\tint row=0;\n\twhile(true){\n\t\tif((2*i*(i+2)+1)>n){\n\t\t\trow=i-1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tfor(int i =row;i>=1;i--){\n\t\tfor(int k=row-i;k>=1;k--)cout<<\" \";\n\t\tfor(int j=i*2+1;j>=1;j--)cout<< s;\n\t\tcout <<endl;\n\t}\n\tfor(int i=0;i<row;i++){\n\tcout<<\" \";\t\n\t}\n\tif(n>=7){cout <<s<<endl; \n\t}\n\telse{\n\t\tcout<<s<<endl;\n\t}\n\t\n     \n\tfor(int i =1;i<=row;i++){\n\t\tfor(int k=row-i;k>=1;k--)cout<<\" \";\n\t\tfor(int j=i*2+1;j>=1;j--)cout<< s;\n\t\tcout <<endl;\n\t} \n\t\n\tint sum=n-2*row*(row+2)-1;\n\t//if(sum!=0)\n\tcout<<sum;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731331": {
        "problemSetProblemId": "1767420176117731331",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    string s;\n    cin>>s;\n    map<char,int>ma;\n    for(int i=0;i<s.size();i++){\n        ma[s[i]]++;\n    }\n    for(auto it=ma.begin();it!=ma.end();it++){\n        cout<<it->first<<\":\"<<it->second<<endl;\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731332": {
        "problemSetProblemId": "1767420176117731332",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int f;\n    cin>>f;\n    cout<<\"Celsius = \"<<5*(f-32)/9;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731333": {
        "problemSetProblemId": "1767420176117731333",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    map<int,pair<string,int>>m;\n    int n,sj,ks,mm,x;\n    string sf;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>sf>>sj>>ks;\n        pair<string,int> p(sf,ks);\n        m[sj]=p;\n    }\n    cin>>mm;\n    for(int i=0;i<mm;i++){\n        cin>>x;\n        cout<<m[x].first<<\" \"<<m[x].second<<endl;\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731334": {
        "problemSetProblemId": "1767420176117731334",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "// #include<bits/stdc++.h>\n// using namespace std;\n// typedef long long ll;\n// bool ss(ll n){\n//     for(int i=2;i<sqrt(n)+1;i++){\n//         if(n%i==0){\n//             return false;\n//         }\n//     }\n//     return true;\n// }\n// int main(){\n//     ll n;\n//     set<ll>s;\n//     cin>>n;\n//     if(ss(n)){\n//         cout<<1<<endl;\n//         cout<<n;\n//         return 0;\n//     }\n//     for(int i=2;i<sqrt(n)+1;i++){\n//         if(n%i==0){\n//             s.insert(i);\n//         }\n//     }\n//     int last,ma=1,qi,k=1,mqi=*s.begin(),cj;\n//     for(auto it=s.begin();it!=s.end();it++){\n//         if(it==s.begin()){\n//             last=*it;\n//             qi=*it;\n//             k=1;\n//             cj=*it;\n//         }else{\n//             if(*it==last+1){\n//                 cj*=(*it);\n//                 if(n%cj==0){\n//                     k++;\n//                     if(k>ma){\n//                         ma=k;\n//                         mqi=qi;\n//                     }\n//                 }else{\n//                     qi=*it;\n//                     k=1;\n//                     cj=*it;\n//                 }\n//             }else{\n//                 qi=*it;\n//                 k=1;\n//                 cj=*it;\n//             }\n//             last=*it;\n//         }\n//     }\n//     cout<<ma<<endl;\n//     for(int i=mqi;i<mqi+ma;i++){\n//         if(i==mqi){\n//             cout<<i;\n//         }else{\n//             cout<<\"*\"<<i;\n//         }\n//     }\n// }\n#include<iostream>\n#include<cmath>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    int max=0;\n    int sta;\n    for(int i=2;i<sqrt(n);i++){\n        int nn=n;\n        int num=0;\n        for(int j=i;nn%j==0&&nn!=0;j++){\n            nn/=j;\n            num++;\n        }\n        if(num>max){\n            sta=i;\n            max=num;\n        }\n    }\n    if(max==0){\n        cout<<1<<endl;\n        cout<<n;\n    }\n    else{\n        cout<<max<<endl;\n        cout<<sta;\n        for(int i=1;i<max;i++){\n            cout<<\"*\"<<sta+i;\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731335": {
        "problemSetProblemId": "1767420176117731335",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\n#include<string.h>\nint main()\n{\nchar str[100];\nint len;\nint i;\ngets(str);\nlen=strlen(str);\nfor(i=0;i<len;i++)\n{\nswitch(str[i])\n{\ncase '-':printf(\"fu\");break;\ncase '1':printf(\"yi\");break;\ncase '2':printf(\"er\");break;\ncase '3':printf(\"san\");break;\ncase '4':printf(\"si\");break;\ncase '5':printf(\"wu\");break;\ncase '6':printf(\"liu\");break;\ncase '7':printf(\"qi\");break;\ncase '8':printf(\"ba\");break;\ncase '9':printf(\"jiu\");break;\ncase '0':printf(\"ling\");break;\n}\nif(i<len-1)\nprintf(\" \");\n}\nreturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731336": {
        "problemSetProblemId": "1767420176117731336",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n    int A,B,NUM,X,add;\n    X=0;\n    scanf(\"%d %d\",&A,&B);\n    if(-100<=A && A<=100 && -100<=B && B<=100 && A<=B)\n    {\n        for(NUM=A;NUM<=B && NUM>=A;NUM++)\n        {\n            printf(\"%5d\",NUM);\n            X++;\n            if(X%5==0&&NUM!=B)\n            {\n                printf(\"\\n\");\n            }\n            else if(NUM==B)\n            {\n                add=(A+B)*(B-A+1)/2;\n                printf(\"\\nSum = %d\",add);\n            }\n \n            }\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731337": {
        "problemSetProblemId": "1767420176117731337",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL gcd(LL a, LL b){  \n\tif(b) return gcd(b, a%b);\n\treturn a;\t\n}\n\nvoid merge(LL &a1, LL &b1, LL &a2, LL &b2){  \n\tLL fenmu = b1*b2/gcd(b1,b2);  \n\tLL fenzi = (fenmu/b1)*a1+(fenmu/b2)*a2;  \n\ta1 = fenzi;\n\tb1 = fenmu;\n}\nint main(){\n\tLL n,a1,b1,a2,b2;\n\tchar ch;\n\tcin >> n;\n\tcin >> a1 >> ch >> b1;  \n\tfor(int i=0; i<n-1; i++){\n\t\tcin >> a2 >> ch >> b2;\n\t\tmerge(a1,b1,a2,b2);  \n\t}\n\tLL k = gcd(a1, b1); \n\ta1 = a1/k;\n\tb1 = b1/k;\n\tif(a1&&a1/b1==0)cout<<a1%b1<<\"/\"<<b1;  \n    else if(a1%b1==0) cout<<a1/b1; \n    else cout<<a1/b1<<\" \"<<a1%b1<<\"/\"<<b1;  \n\treturn 0;\n} \n"
        },
        "problemId": "0"
    },
    "1767420176117731338": {
        "problemSetProblemId": "1767420176117731338",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n    int a,b,c;\n   scanf(\"%d %d %d\",&a,&b,&c);\n    if(a>=b&&a>=c){\n        if(b>=c)\n    printf(\"%d->%d->%d\",c,b,a);\n    else\n    printf(\"%d->%d->%d\",b,c,a);\n    }\n    else if(b>=a&&b>=c){\n        if(a>=c)\n        printf(\"%d->%d->%d\",c,a,b);\n        else\n        printf(\"%d->%d->%d\",a,c,b);\n    }\n     else if(c>=a&&c>=b){\n        if(a>=b)\n        printf(\"%d->%d->%d\",b,a,c);\n        else\n        printf(\"%d->%d->%d\",a,b,c);\n    }\n    return 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731339": {
        "problemSetProblemId": "1767420176117731339",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint main ()\n{\n     string s1, s2;\n     getline(cin, s1);\n     getline(cin, s2);\n     for(int i = 0; i < s1.length(); i++){\n     \tfor(int j = 0; j < s2.length(); j++){\n     \t\tif(s1[i] == s2[j]){\n     \t\t\t//标志位 \n     \t\t\ts1[i] = '2';\n\t\t\t }\n\t\t } \n\t }\n\t for(int i = 0; i < s1.length(); i++){\n\t \t//如果是标志位，则什么也不输出，跳过就行 \n\t \tif(s1[i] != '2'){\n\t \t\tcout << s1[i];\n\t\t}\n\t } \n\t return 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731340": {
        "problemSetProblemId": "1767420176117731340",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n\nusing namespace std;\nint main()\n{\n\tint n,s=2;\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\ts*=2;\n\t}\n\tprintf(\"2^%d = %d\",n,s);\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731341": {
        "problemSetProblemId": "1767420176117731341",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include <stdio.h>\nint main()\n{\n\tint n;\n\tint m=1;\n\tint j=1;\n\tint i;\n\tscanf(\"%d\",&n);  //输入一个正整数\n\tfor(i=n;i>1;i--){\n\t\t\n\t\tj=i*j;      //在for循环中计算输入正整数的阶乘\n\t\t\n\t\tif(i==2&&n>1){\n\t\t\tn=n-1;\n\t\t\tm=j+m;\n\t\t\tj=1;\n\t\t\ti=n+1;\n\t\t}          //使输入正整数逐步-1，计算阶乘和\n\t}\n\tprintf(\"%d\",m);    //输出结果\n\t\n}"
        },
        "problemId": "0"
    },
    "1767420176117731342": {
        "problemSetProblemId": "1767420176117731342",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "This is a simple problem."
        },
        "problemId": "0"
    },
    "1767420176117731343": {
        "problemSetProblemId": "1767420176117731343",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include <stdio.h> \n \nint main(void)\n{\n  int n,i,j;\n  char a;\n  scanf(\"%d %c\",&n,&a);\n \n  for(i=0;i<((int)((n*0.5)+0.5));i++){\n    for(j=0;j<n;j++){\n        printf(\"%c\",a);\n      }\n      printf(\"\\n\");\n  }\n  return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731344": {
        "problemSetProblemId": "1767420176117731344",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint a[17] = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};\nint b[11] = {1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2};\nstring s;\nbool isTrue() {\n    int sum = 0;\n    for (int i = 0; i < 17; i++) {\n        if (s[i] < '0' || s[i] > '9') return false;\n        sum += (s[i] - '0') * a[i];\n    }\n    int temp = (s[17] == 'X') ? 10 : (s[17] - '0');\n    return b[sum%11] == temp;\n}\nint main() {\n    int n, flag = 0;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> s;\n        if (!isTrue()) {\n            cout << s << endl;\n            flag = 1;\n        }\n    }\n    if (flag == 0) cout << \"All passed\";\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731345": {
        "problemSetProblemId": "1767420176117731345",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\n\nusing namespace std;\nint f(string n){        //此函数用来返回字符串里面2的个数\n    int num=0,i,t;\n    t=n.size();   \n    for(i=0;i<t;i++)\n        if(n[i]=='2') num++;\n    return num;\n}\nint main(){\n    string m;\n    double g,n,r;   //因为后面的最终结果为浮点型，方便起见可以直接定义为实型，要不然若是定义为整形下面计算还要乘以1.0\n    cin>>m;\n    r=m.size();     //r为字符串长度\n    n=f(m);     //2的个数\n    if(m[0]!='-'){\n        if((m[r-1]-'0')%2==0)\n            g=n/r*2*100;\n        else g=n/r*100;\n    }\n    else{\n        if((m[r-1]-'0')%2==0)\n            g=n/(r-1)*3*100;\n        else g=n/(r-1)*1.5*100;\n    }\n    printf(\"%.2f%%\\n\",g);   //输出保留两位小数\nreturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731346": {
        "problemSetProblemId": "1767420176117731346",
        "programmingSubmissionDetail": {
            "compiler": "GO",
            "program": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar time string\n\t_,_=fmt.Scan(&time)\n\ttmp := strings.Split(time,\":\")\n\thour,_ := strconv.Atoi(tmp[0])\n\tsecond,_ := strconv.Atoi(tmp[1])\n\tstr := \"\"\n\tif hour>=00 && hour<=12 { \n\t\tfmt.Printf(\"Only %s:%s.  Too early to Dang.\",tmp[0],tmp[1])\n\t\treturn\n\t}else{\n\t\tfor i:=0; i<hour-12; i++ {\n\t\t\tstr += \"Dang\"\n\t\t}\n\t}\n\tif second!=0 { // 如果正好在某个整点敲，那么“当”数就等于那个整点数\n\t\t\t\t   //如果过了整点，就敲下一个整点数,这个不是0的话，就不是整点了，就要再多加一个！\n\t\tstr +=\"Dang\"\n\t}\n\tfmt.Printf(str)\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731347": {
        "problemSetProblemId": "1767420176117731347",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\n\nint n;\nint a, b;\t\t\t\t\t//两人的酒量 \n\nint main()\n{\n\tcin >> a >> b >> n;\n\tint aa = a, bb = b;\n\tint aj, ah, bj, bh;\n\tfor(int i = 1;i <= n;i++){\n\t\tcin >> aj >> ah >> bj >> bh;\n\t\tint x = aj + bj;\n\t\tif(ah == x && bh == x)\tcontinue;\n\t\telse if(ah == x)\ta--;\n\t\telse if(bh == x)\tb--;\n\t\tif(a < 0){\n\t\t\tcout << \"A\" << endl << bb - b << endl;\n\t\t\treturn 0;\n\t\t}\t\n\t\telse if(b < 0){\n\t\t\tcout << \"B\" << endl << aa - a << endl;\n\t\t\treturn 0;\n\t\t}\t\n\t}\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731348": {
        "problemSetProblemId": "1767420176117731348",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream> \nusing namespace std;\nconst int  N = 100000;\nint main()\n{\n    int n;\n    int k;\n    cin >> n;\n    int id;    \n    int x[N] = {0};\n    for(int i = 0; i < n; i ++)\n    {\n        cin >> k;\n        for(int j = 0; j < k; j ++)\n        {\n            cin >> id;\n            if(k != 1)\n                x[id] = 1;\n        }\n    }\n    int m;\n    cin >> m;\n    int idx;\n    int sum = 0;\n    for(int i = 0; i < m; i ++)\n    {\n        cin >> idx;\n        if(x[idx] == 0)\n        {\n              if(sum != 0)\n              {\n                  printf(\" %05d\", idx);\n              }\n              else if(sum == 0)\n              {\n                  printf(\"%05d\", idx);\n              }\n            x[idx] = 1;\n            sum ++;\n        }\n    }\n    if(sum == 0)\n        cout << \"No one is handsome\"; \n    cout << endl;\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731349": {
        "problemSetProblemId": "1767420176117731349",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "I'm gonna WIN!\nI'm gonna WIN!\nI'm gonna WIN!"
        },
        "problemId": "0"
    },
    "1767420176117731350": {
        "problemSetProblemId": "1767420176117731350",
        "programmingSubmissionDetail": {
            "compiler": "JAVAC",
            "program": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int oddCount = 0;\n        int evenCount = 0;\n \n        for (int i = 0; i < n; i++) {\n            int num = input.nextInt();\n            if (num % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n \n        System.out.println(oddCount + \" \" + evenCount);\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731351": {
        "problemSetProblemId": "1767420176117731351",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    string c;\n    char f[10000];\n    int a[4]={0,1,2,3},l=0,j=0,i,m;//a[0]~a[3]分别表示G P L T在字符串f中的下角标\n    cin>>c;\n    l=c.length();//取字符串c的长度\n    for(i=0;i<l;i++)\n    {\n        if(c[i]=='G'||c[i]=='g')\n        {\n            f[a[0]]='G';//按G P L T的顺序存入，下同\n            a[0]+=4;\n            j++;\n        }else if(c[i]=='P'||c[i]=='p')\n        {\n            f[a[1]]='P';\n            a[1]+=4;\n            j++;\n        }else if(c[i]=='L'||c[i]=='l')\n        {\n            f[a[2]]='L';\n            a[2]+=4;\n            j++;\n        }else if(c[i]=='T'||c[i]=='t')\n        {\n            f[a[3]]='T';\n            a[3]+=4;\n            j++;\n        }\n    }\n    i=0;\n    l=0;\n    while(i<j)//j为四种字母的个数\n    {\n        if(f[l]!=0)\n        {\n        cout<<f[l];\n        i++;\n        }\n        l++;\n    }\n    return 0;\n}\n\n"
        },
        "problemId": "0"
    },
    "1767420176117731352": {
        "problemSetProblemId": "1767420176117731352",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include <stdio.h>\nint main () {\n    int D;\n    scanf(\"%d\", &D);\n    printf(\"%d\",1+(D-1+2)%7);\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731353": {
        "problemSetProblemId": "1767420176117731353",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<string>\nusing namespace std;\nint main()\n{\n\tstring A,B;\n\tcin>>A;\n\tgetchar(); //把A和B中间的空格跳过\n\tgetline(cin,B);   //可读入B字符串的空格 \n\tint flag=0,flag2=0; //标记 \n\t\n\tfor(int i=0;i<A.length();i++)\n\t{\n\t\tif(A.length()<1||A.length()>4)\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;  //需要是一位数到四位数 \n\t\t}\n\t\tif(A[i]<'0'||A[i]>='10') \n\t   {\n\t\t flag=1;  //不满足标记为1 \n\t\t break;\n\t   }\n\t}\n\t\n\tfor(int i=0;i<B.length();i++)\n\t{\n\t\tif(B.length()<1||B.length()>4)\n\t\t{\n\t\t\tflag2=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(B[i]<'0'||B[i]>='10')\n\t   {\n\t\t flag2=1;\n\t\t break;\n\t   }\n\t}\n\t   int temp1=0,temp2=0;\n\t\tfor(int i=0;i<A.size();i++)\n\t   {\n\t\ttemp1=A[i]-'0'+temp1*10;\n\t   }\n\t   for(int i=0;i<B.size();i++)\n\t   {\n\t\ttemp2=B[i]-'0'+temp2*10;\n\t   }\n\t   if(temp1<1||temp1>1000) flag=1;\n\t   if(temp2<1||temp2>1000) flag2=1;\n\t   \n\tif(flag==1&&flag2==1)\n\tcout<<\"? + ? = ?\";\n\tif(flag==1&&flag2==0)\n\tcout<<\"? + \"<<B<<\" = ?\";\n\tif(flag==0&&flag2==1)\n\tcout<<A<<\" + ? = ?\";\n\tif(flag==0&&flag2==0)\n\t{\n\t\t\n\t\tcout<<A<<\" + \"<<B<<\" = \"<<temp1+temp2;\n\t}\n\t\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731354": {
        "problemSetProblemId": "1767420176117731354",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "I\n \nL\no\nv\ne\n \nG\nP\nL\nT"
        },
        "problemId": "0"
    },
    "1767420176117731355": {
        "problemSetProblemId": "1767420176117731355",
        "programmingSubmissionDetail": {
            "compiler": "GO",
            "program": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tvar str string\n\tvar opList []int\n\t_,_=fmt.Scan(&str)\n\tphoneMap := make(map[rune]int)\n\tfor _,i := range str{  //用map去存这个电话的数字\n\t\tphoneMap[i-'0'] = 1\n\t}\n\tfor i:=0;i<=9;i++ {\n\t\tif phoneMap[rune(i)] == 1 {\n\t\t\topList = append(opList, i) //拿到去重后的电话数字列表\n\t\t}\n\t}\n\tsort.Ints(opList)  // sort正序排\n\tvar opListReserve []int\n\tfor i:=len(opList)-1 ; i>=0 ; i-- {\n\t\topListReserve = append(opListReserve, opList[i]) // 要倒序排\n\t}\n\ts:=\"\"\n\top := \"\"\n\tfor _,i:= range opListReserve{\n\t\top+=strconv.Itoa(i)+\",\"\n\t}\n\tfor _,i := range str{  \t\t//遍历一遍电话号码\n\t\tfor index,j := range opListReserve{ \t// 再遍历一遍去重的电话号码\n\t\t\tif i-'0' == rune(j) {  \t\t\t\t\t// 如果是等于的话，就记录去重列表中的电话号码的下标\n\t\t\t\ts+=strconv.Itoa(index)+\",\"\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"int[] arr = new int[]{%s};\\n\",op[:len(op)-1]) \t// 把最后一个逗号省去了\n\tfmt.Printf(\"int[] index = new int[]{%s};\",s[:len(s)-1])\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731356": {
        "problemSetProblemId": "1767420176117731356",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        long long m;\n        cin >> m;\n        long long time = sqrt(m);\n        long long k = 2;\n        if (m > 1 && m < 4) {\n            cout << \"Yes\" << endl;\n            continue;\n        } else if (m <= 1) {\n            cout << \"No\" << endl;\n            continue;\n        }\n        bool flag = true;\n        while (k <= time && k < m) {\n            if (m % k == 0) {\n                flag = false;\n                break;\n            }\n            k++;\n        }\n        if (flag) {\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731357": {
        "problemSetProblemId": "1767420176117731357",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    printf(\"%.1f\",(n-100)*0.9*2);\n}"
        },
        "problemId": "0"
    },
    "1767420176117731358": {
        "problemSetProblemId": "1767420176117731358",
        "programmingSubmissionDetail": {
            "compiler": "PYTHON3",
            "program": "# By jurio.\nN = int(input())\n\nlst_m, lst_f = [], []\nfor i in range(N):\n    lst_temp = list(input().split())\n    if int(lst_temp[0]):\n        lst_m.append([i+1, lst_temp[-1]])\n    else:\n        lst_f.append([i+1, lst_temp[-1]])\n\nif len(lst_f) == len(lst_m):\n    p_m, p_f = 0, 0\n    while p_f + p_m < len(lst_f):\n        if lst_f[p_f][0] < lst_m[p_m][0]:\n            print(lst_f[p_f][-1], lst_m[-p_f-1][-1])\n            p_f += 1\n        else:\n            print(lst_m[p_m][-1], lst_f[-p_m-1][-1])\n            p_m += 1\nelse:\n    print('Error!')\n"
        },
        "problemId": "0"
    },
    "1767420176117731359": {
        "problemSetProblemId": "1767420176117731359",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<stdio.h>\nint main()\n{\nint n,i,h,w;\ndouble std;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n   scanf(\"%d\",&h);\n   scanf(\"%d\",&w);\n   std=(h-100)*18;\n   if(100*w<=9*std){\n    printf(\"You are tai shou le!\\n\");\n   }\n else if(100*w>=11*std){\n  printf(\"You are tai pang le!\\n\");\n }else{\n  printf(\"You are wan mei!\\n\");\n }\n  }\n  return 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731360": {
        "problemSetProblemId": "1767420176117731360",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\n#include<string.h>\nint main()\n{\n\tint n;\n\tchar c,str[40000];\n\tscanf(\"%d %c\",&n,&c);\n\tgetchar();\n\tgets(str);\n\tint len = strlen(str);\n\tif(len<=n)\n\t{\n\t\tfor(int i=0;i<n-len;i++)printf(\"%c\",c);\n\t\tputs(str);\n\t}\n\tif(len > n)  \n    {  \n        for(int i=len-n;i<len;i++)  \n        {  \n            putchar(str[i]);  \n        }  \n    }  \n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731361": {
        "problemSetProblemId": "1767420176117731361",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(void)\n{\n    int n,f,m,c1,c2,c3,c4,t,count;\n    scanf(\"%04d %d\",&n,&m);\n     f=n; //保留最初的年份，因为后面的循环会依次增加年份\n    while(1){\n            t=n;\n            c1=t/1000; //找出千位数 如1988中的1\n            t=t%1000;\n            c2=t/100; //找出百位数 如1988中的9\n            t=t%100;\n            c3=t/10; //找出十位数 如1988中的8\n            c4=t%10; //找出个位数 如1988中的8\n            count=1;\n            if(c1!=c2&&c1!=c3&&c1!=c4){ \n            //这条语句是在判断，c1是不是和c2，c3，c4都不相等，是的话就有两个不一样啦\n                count++;\n            }\n            if(c2!=c3&&c2!=c4){\n            //此句在判断c2是否和c3，c4相等，若都不相等就有三个不一样了\n                count++;\n            }\n            if(c3!=c4){\n            //此句在判断c3和c4是否相等，若不相等，则有四个不一样。\n                count++;\n            }\n            if(count==m) break;\n            n++; \n        //将n++放在后面，而不是前面是因为 初始的n也是要进入循环的。不然测试案例2，会报错啦~\n        }\n    printf(\"%d %04d\",n-f,n);\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731362": {
        "problemSetProblemId": "1767420176117731362",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include <stdio.h>\n \nint main()\n{\n\tint n,m;//n表示点赞的博文条数，m表示点赞的每条博文对应的标签数。 \n\tint type[1001] = {0};//统计标签出现次数 \n\tint t,i;\n\tscanf(\"%d\",&n);\n\twhile(n > 0)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\twhile(m > 0)\n\t\t{\n\t\t\tscanf(\"%d\",&t);\n\t\t\ttype[t] ++;\n\t\t\tm--;\n\t\t}\n\t\tn --;\n\t}\n\tint max = 0,maxid = 0;\n\tfor(i = 1000;i>=0;i--)//找出出现次数最多的标签 \n\t{\n\t\tif(type[i] > max)\n\t\t{\n\t\t\tmax = type[i];\n\t\t\tmaxid = i;\n\t\t}\n\t}\n\tprintf(\"%d %d\",maxid,max);\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731363": {
        "problemSetProblemId": "1767420176117731363",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n    char arr[10001][11];\n    int i;\n    for(i=0;;i++)\n    {\n        scanf(\"%s\",arr[i]);\n        if(arr[i][0]=='.')\n            break;\n    }\n    if(i<2)\n    {\n        printf(\"Momo... No one is for you ...\");\n    }\n    else if(i<14)\n    {\n        printf(\"%s is the only one for you...\",arr[1]);\n    }\n    else\n    {\n        printf(\"%s and %s are inviting you to dinner...\",arr[1],arr[13]);\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731364": {
        "problemSetProblemId": "1767420176117731364",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    cout<<n*m;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731365": {
        "problemSetProblemId": "1767420176117731365",
        "programmingSubmissionDetail": {
            "compiler": "PYTHON3",
            "program": "a, b = map(int, input().split())\n\nif b == 0:\n    print(f\"{a}/{b}=Error\")\nelif b < 0:\n    print(f\"{a}/({b})={a/b:.2f}\")\nelse:\n    print(f\"{a}/{b}={a/b:.2f}\")\n"
        },
        "problemId": "0"
    },
    "1767420176117731366": {
        "problemSetProblemId": "1767420176117731366",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "Hello World\nHello New World"
        },
        "problemId": "0"
    },
    "1767420176117731367": {
        "problemSetProblemId": "1767420176117731367",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n\tint n;    //相当于输出数组的行 \n\tscanf(\"%d \",&n);\n\tchar a[1001];   //存放输入的字符串 \n\tgets(a);       \n\tint len=strlen(a);     //求字符串的长度  \n\tint row;   //列 \n\tif(len%n){\n\t\trow=len/n+1;\n\t}else{\n\t\trow=len/n;\n\t}\t\n\tchar p[n][row];\n\t//初始化     将所有元素初始化为空格 \n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<row;j++){\n\t\t\tp[i][j]=' ';\n\t\t} \n\t}\n\tint k=0;\n\tfor(int i=row-1;i>=0;i--){    //注意这个for循环，大家一定要搞清楚i，j \n\t\tfor(int j=0;j<n;j++){\n\t\t\tp[j][i]=a[k];\n\t\t\tif(k==len-1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t} \n\t}\n\t//打印最终结果 \n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<row;j++){\n\t\t\tprintf(\"%c\",p[i][j]);\n\t\t} \n\t\tif(i!=n-1){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n} \n"
        },
        "problemId": "0"
    },
    "1767420176117731368": {
        "problemSetProblemId": "1767420176117731368",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nstruct people\n{\n    char sex;//性别M男，F女\n    double sg;//身高\n};\nint main()\n{\n    int n;//录入n个人\n    cin>>n;\n    struct people p[n];\n    for(int i=0;i<n;i++)\n        cin>>p[i].sex>>p[i].sg;//录入个人信息\n    for(int i=0;i<n;i++)\n    {\n        if(p[i].sex=='M')//男人时候\n            cout<<fixed<<setprecision(2)<<p[i].sg/1.09<<endl;\n        else//女人时候\n            cout<<fixed<<setprecision(2)<<p[i].sg*1.09<<endl;\n    }\n    return 0;\n}\n\n"
        },
        "problemId": "0"
    },
    "1767420176117731369": {
        "problemSetProblemId": "1767420176117731369",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint cnt = 0;\n\twhile(true)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcnt++;\n\t\tif(x == 250)\n\t\t{\n\t\t\tprintf(\"%d\\n\",cnt);\n\t\t\treturn 0;\n\t\t}\t\t\n\t}\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731370": {
        "problemSetProblemId": "1767420176117731370",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include <stdio.h>\n#include <stdlib.h>\n \nmain()\n{\n \n    int a,b,c;\n    scanf(\"%d-%d-%d\",&b,&c,&a);\n    printf(\"%04d-%02d-%02d\\n\",a,b,c);\n  //04，02，02分别保留四位，两位，两位数字，避免单数月份日期格式不对\n    return 0;\n}\n "
        },
        "problemId": "0"
    },
    "1767420176117731371": {
        "problemSetProblemId": "1767420176117731371",
        "programmingSubmissionDetail": {
            "compiler": "JAVAC",
            "program": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(in.readLine());\n        for (int i = 0; i < N; i++) {\n            // double除以0不会报错，返回NaN\n            double sum = 0;\n            int cnt = 0;\n            String[] record = in.readLine().split(\" \");\n            Map<String, Integer> map = new HashMap<String, Integer>();\n            // 将0作为书号输入时，表示一天工作结束\n            while (!record[0].equals(\"0\")) {\n                // 记录开始时间\n                if (record[1].equals(\"S\")) {\n                    String[] x = record[2].split(\":\");\n                    int start = Integer.parseInt(x[0]) * 60 + Integer.parseInt(x[1]);\n                    // 测试点1，只有借没有还，记录最新的借\n                    map.put(record[0], start);\n                }\n                // 记录结束时间\n                else if (record[1].equals(\"E\")) {\n                    String[] x = record[2].split(\":\");\n                    int end = Integer.parseInt(x[0]) * 60 + Integer.parseInt(x[1]);\n                    // 检查该书是否被借走\n                    if (map.containsKey(record[0])) {\n                        // 存在借阅记录，借书次数+1\n                        cnt++;\n                        // 记录借阅时间\n                        sum += (end - map.get(record[0]));\n                        map.remove(record[0]);\n                    }\n\n                }\n                record = in.readLine().split(\" \");\n            }\n            System.out.printf(\"%d %d\\n\", cnt, Math.round(sum / cnt));\n        }\n\n    }\n\n}"
        },
        "problemId": "0"
    },
    "1767420176117731372": {
        "problemSetProblemId": "1767420176117731372",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n    int K, count = 0;\n    scanf(\"%d\", &K);\n    char s1[10] = \"ChuiZi\", s2[10] = \"JianDao\", s3[10] = \"Bu\";\n    char str[20];\n    while (scanf(\"%s\", str) != EOF)\n    {\n        count++;\n        if (str[0] == 'C')\n        {\n            if (count > K)\n            {\n                count = 0;\n                printf(\"%s\\n\", str);\n            }\n            else\n                printf(\"%s\\n\", s3);\n        }\n        else if (str[0] == 'J')\n        {\n            if (count > K)\n            {\n                count = 0;\n                printf(\"%s\\n\", str);\n            }\n            else\n                printf(\"%s\\n\", s1);\n        }\n        else if (str[0] == 'B')\n        {\n            if (count > K)\n            {\n                count = 0;\n                printf(\"%s\\n\", str);\n            }\n            else\n                printf(\"%s\\n\", s2);\n        }\n        else if (str[0] == 'E')\n            break;\n    }\n    return 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731373": {
        "problemSetProblemId": "1767420176117731373",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    string s;\n    cin>>s;\n    cout<<\"Hello \"<<s;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731374": {
        "problemSetProblemId": "1767420176117731374",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    int s=1;\n    int num=1;\n    while(s<n){\n        s=s*10+1;\n        num++;\n    }\n    while(1){\n        cout<<s/n;\n        s=s%n;\n        if(s==0)\n            break;\n        else{\n            s=s*10+1;\n            num++;\n        }\n    }\n    cout<<' '<<num;\n    return 0;\n}\n "
        },
        "problemId": "0"
    },
    "1767420176117731375": {
        "problemSetProblemId": "1767420176117731375",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h> \nusing namespace std;\n \nclass zhuangshui\n{\n\tpublic:\n               char name[30];\n\t       int huxi;\n\t       int maibo;\n}a[10];\n \nint main() \n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%s %d %d\",&a[i].name,&a[i].huxi,&a[i].maibo);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(a[i].huxi < 15 || a[i].huxi > 20 || a[i].maibo < 50 ||a[i].maibo > 70)\n\t\t{\n\t\t\tprintf(\"%s\\n\",a[i].name);\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731376": {
        "problemSetProblemId": "1767420176117731376",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(){\n    int hang1;\n    int lie1;\n    int hang2;\n    int lie2;\n    cin>>hang1>>lie1;\n    int a1[hang1][lie1];\n    for(int i=0;i<hang1;i++){\n        for(int j=0;j<lie1;j++){\n            cin>>a1[i][j];\n        }\n    }\n    cin>>hang2>>lie2;\n    int a2[hang2][lie2];\n    for(int i=0;i<hang2;i++){\n        for(int j=0;j<lie2;j++){\n            cin>>a2[i][j];\n        }\n    }\n    if(lie1!=hang2){\n        cout<<\"Error: \"<<lie1<<\" != \"<<hang2;\n    }\n    else{\n        cout<<hang1<<\" \"<<lie2<<endl;\n        int a3[hang1][lie2];\n        for(int i=0;i<hang1;i++){\n            for(int j=0;j<lie2;j++){\n                a3[i][j]=0;\n            }\n        }\n        for(int i=0;i<hang1;i++){\n            for(int j=0;j<lie2;j++){\n                for(int k=0;k<hang2;k++){\n                    a3[i][j]+=a1[i][k]*a2[k][j];\n                }\n            }\n        }\n        for(int i=0;i<hang1;i++){\n            for(int j=0;j<lie2;j++){\n                if(j==lie2-1)\n                    cout<<a3[i][j]<<endl;\n                else\n                    cout<<a3[i][j]<<\" \";\n            }\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731377": {
        "problemSetProblemId": "1767420176117731377",
        "programmingSubmissionDetail": {
            "compiler": "JAVAC",
            "program": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int schoolCount = scanner.nextInt();\n        int[] teamCount = new int[1000];\n        for (int i = 1; i <= schoolCount; i++) {\n            teamCount[i] = scanner.nextInt();\n        }\n        for (int i = 1; i <= schoolCount; i++) {\n            System.out.println(\"#\" + i);\n            int studentCount = 0;\n            int step = 2;\n            if (schoolCount >= 2) {\n                step = schoolCount;\n            }\n            int seatNumber = i;\n            for (int j = 1; j <= teamCount[i]; j++) {\n                int flag = 0;\n                for (int k = 1; k <= 10; k++) {\n                    if (flag != 0) {\n                        System.out.print(\" \");\n                    }\n                    flag = 1;\n                    System.out.print(seatNumber);\n                    studentCount++;\n                    if (studentCount % 10 == 0) {\n                        for (int o = 1; o < i; o++) {\n                            if (studentCount == teamCount[o] * 10 && step > 2) {\n                                step--;\n                            }\n                        }\n                    }\n                    seatNumber += step;\n                    if (studentCount % 10 == 0) {\n                        for (int o = i + 1; o <= schoolCount; o++) {\n                            if (studentCount == teamCount[o] * 10 && step > 2) {\n                                step--;\n                            }\n                        }\n                    }\n                }\n                System.out.println();\n            }\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731378": {
        "problemSetProblemId": "1767420176117731378",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\n#include<math.h>\nint main(){\t\n\tint l,n,t;\n\tscanf(\"%d%d\",&l,&n);\n\tint xx[l],i;\n\tt = pow(26,l)-n;                //pow(a,b)是标准库里一个数学函数，求的是a的b次方，头文件为 #include<math.h> \n\tfor(i=0;i<l;i++){     \n\t\txx[i]=t%26; \t        \t//用创建的数组保存第 i 个位置上对26取得的余数； \n\t\tt/=26;\n\t}\n\tfor(i=l-1;i>=0;i--)\n\t\tprintf(\"%c\",'a'+xx[i]);     //a 的ASCII码加上余数，就得到对应字母的ASCII码，不懂的可以取了解一下ASCII \n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731379": {
        "problemSetProblemId": "1767420176117731379",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include <stdio.h>\nint main()\n{\n    float a, b, c;\n    scanf(\"%f%f\", &a, &b);\n    c=a*b*0.1;\n    printf(\"%.2f\",c);\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731380": {
        "problemSetProblemId": "1767420176117731380",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "2018\nwo3 men2 yao4 ying2 !"
        },
        "problemId": "0"
    },
    "1767420176117731381": {
        "problemSetProblemId": "1767420176117731381",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    for(int i=0;i<n+m;i++){\n        cout<<\"Wang!\";\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731382": {
        "problemSetProblemId": "1767420176117731382",
        "programmingSubmissionDetail": {
            "compiler": "JAVAC",
            "program": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n \n        char c = scanner.next().charAt(0);\n        int n = scanner.nextInt();\n        scanner.nextLine(); // 消耗换行符\n \n        String[] s = new String[n];\n        for (int i = 0; i < n; i++) {\n            s[i] = scanner.nextLine();\n        }\n \n        boolean issame = true;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int a = n - i - 1;\n                int b = n - j - 1;\n                if (s[a].charAt(b) != s[i].charAt(j)) {\n                    issame = false;\n                    break;\n                }\n            }\n            if (!issame) {\n                break;\n            }\n        }\n \n        if (issame) {\n            System.out.println(\"bu yong dao le\");\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (s[i].charAt(j) == ' ') {\n                        System.out.print(' ');\n                    } else {\n                        System.out.print(c);\n                    }\n                }\n                System.out.println();\n            }\n        } else {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    int a = n - i - 1;\n                    int b = n - j - 1;\n                    if (s[a].charAt(b) == ' ') {\n                        System.out.print(' ');\n                    } else {\n                        System.out.print(c);\n                    }\n                }\n                System.out.println();\n            }\n        }\n \n        scanner.close();\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731383": {
        "problemSetProblemId": "1767420176117731383",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n    int ag=0;\n    int bg=0;\n    int ap=0;\n    int bp=0;\n    scanf(\"%d %d\",&ag,&bg);\n    for(int i=0;i<3;i++){\n        int t;\n        scanf(\"%d\",&t);\n        if(t==1)\n            bp++;\n        else\n            ap++;\n    }\n    if(ag>bg&&ap>=1)\n        printf(\"The winner is a: %d + %d\",ag,ap);\n    else if(ag>bg&&ap==0)\n        printf(\"The winner is b: %d + %d\",bg,bp);\n    else if(ag<bg&&bp>=1)\n        printf(\"The winner is b: %d + %d\",bg,bp);\n    else if(ag<bg&&bp==0)\n        printf(\"The winner is a: %d + %d\",ag,ap);\n}"
        },
        "problemId": "0"
    },
    "1767420176117731384": {
        "problemSetProblemId": "1767420176117731384",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<cmath>\nusing namespace std;\nstruct ren{\n    string name;\n    int cai;\n};\nint main(){\n    int n;\n    cin>>n;\n    struct ren r[n];\n    int total=0;\n    for(int i=0;i<n;i++){\n        cin>>r[i].name>>r[i].cai;\n        total+=r[i].cai;\n    }\n    int avegban=total/n/2;\n    int min=999;\n    string namea;\n    for(int i=0;i<n;i++){\n        if(abs(r[i].cai-avegban)<min){\n            min=abs(r[i].cai-avegban);\n            namea=r[i].name;\n        }\n    }\n    cout<<avegban<<\" \"<<namea;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731385": {
        "problemSetProblemId": "1767420176117731385",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "PTA shi3 wo3 jing1 shen2 huan4 fa1 !"
        },
        "problemId": "0"
    },
    "1767420176117731386": {
        "problemSetProblemId": "1767420176117731386",
        "programmingSubmissionDetail": {
            "compiler": "JAVAC",
            "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        int count = 0;\n        for (int i = 0; i < input.length(); i++) {\n            if (input.charAt(i) == '6') {\n                count++;\n            } else {\n                if (count <= 3) {\n                    for (int j = 0; j < count; j++) {\n                        System.out.print(\"6\");\n                    }\n                } else if (count > 3 && count <= 9) {\n                    System.out.print(\"9\");\n                } else {\n                    System.out.print(\"27\");\n                }\n                count = 0;\n                System.out.print(input.charAt(i));\n            }\n        }\n        if (count > 0) {\n            if (count <= 3) {\n                for (int j = 0; j < count; j++) {\n                    System.out.print(\"6\");\n                }\n            } else if (count > 3 && count <= 9) {\n                System.out.print(\"9\");\n            } else {\n                System.out.print(\"27\");\n            }\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731387": {
        "problemSetProblemId": "1767420176117731387",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    getchar();\n    for(int j=0;j<n;j++){\n        string str;\n        getline(cin,str);\n        int f1=0;\n        int f2=0;\n        for(int i=0;i<str.length();i++){\n            if(str[i]==','&&str[i-1]=='g'&&str[i-2]=='n'&&str[i-3]=='o')\n                f1=1;\n            if(str[i]=='.'&&str[i-1]=='g'&&str[i-2]=='n'&&str[i-3]=='o')\n               f2=1;\n        }\n        if(f1==0||f2==0)\n            cout<<\"Skipped\"<<endl;\n        else{\n            int kong=0;\n            int weizhi=0;\n            for(int i=str.length()-1;i>=0;i--){\n                if(str[i]==' ')\n                    kong++;\n                if(kong==3){\n                    weizhi=i;\n                    break;\n                }\n            }\n            for(int i=0;i<=weizhi;i++){\n                cout<<str[i];\n            }\n            cout<<\"qiao ben zhong.\"<<endl;\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731388": {
        "problemSetProblemId": "1767420176117731388",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    printf(\"%d\",5000-100*y/2-100*(100-x)/2);\n}"
        },
        "problemId": "0"
    },
    "1767420176117731389": {
        "problemSetProblemId": "1767420176117731389",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n  double a,b,s;\n  scanf(\"%lf %lf\",&a,&b);\n  s=a/(b*b);\n  printf(\"%.1f\\n\",s);\n  if(s>25)\n     printf(\"PANG\");\n  else\n     printf(\"Hai Xing\");\n}"
        },
        "problemId": "0"
    },
    "1767420176117731390": {
        "problemSetProblemId": "1767420176117731390",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main()\n{\n    int N;\n    cin >> N;\n    while(N--)\n    {\n        string str;\n        cin >> str;\n        int sum1 = 0, sum2 = 0;\n        for(int i = 0; i < 6; i++)\n        {\n            if(i < 3)\n            {\n                sum1 += str[i]-'0';\n            }\n            else\n            {\n                sum2 += str[i]-'0';\n            }\n        }\n        if(sum1 == sum2)\n        {\n            cout << \"You are lucky!\" << endl;\n        }\n        else\n        {\n            cout << \"Wish you good luck.\" << endl;\n        }\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731391": {
        "problemSetProblemId": "1767420176117731391",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nint n, sex, s, t;\nint main() {\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> sex >> s >> t;\n\t\tif (sex == 1) {\n\t\t\tif (s < 130) cout << \"duo chi yu! \";\n\t\t\telse if (s == 130) cout << \"wan mei! \";\n\t\t\telse cout << \"ni li hai! \";\n\t\t\tif (t < 27) cout << \"duo chi rou!\\n\";\n\t\t\telse if (t == 27) cout << \"wan mei!\\n\";\n\t\t\telse cout << \"shao chi rou!\\n\";\n\t\t} else {\n\t\t\tif (s < 129) cout << \"duo chi yu! \";\n\t\t\telse if (s == 129) cout << \"wan mei! \";\n\t\t\telse cout << \"ni li hai! \";\n\t\t\tif (t < 25) cout << \"duo chi rou!\\n\";\n\t\t\telse if (t == 25) cout << \"wan mei!\\n\";\n\t\t\telse cout << \"shao chi rou!\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731392": {
        "problemSetProblemId": "1767420176117731392",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <string>\nusing namespace std;\n \n// 函数：字符类型检测\n// 参数：字符c\n// 返回值：字符类型（1：大写字母，2：小写字母，3：数字，4：空格，5：其他字符）\nint check(char c) {\n    if (c >= 'A' && c <= 'Z')\n        return 1;\n    else if (c >= 'a' && c <= 'z')\n        return 2;\n    else if (c >= '0' && c <= '9')\n        return 3;\n    else if (c == ' ')\n        return 4;\n    else\n        return 5;\n}\n \n// 函数：处理输入字符串\n// 参数：原始字符串s\n// 返回值：处理后的字符串\nstring processInput(string s) {\n    string processed = \" \"; // 前后添加空格以方便处理连续空格\n    for (int i = 0; i < s.length(); i++) {\n        // 将大写字母转换为小写字母，除了'I'\n        if (s[i] >= 'A' && s[i] <= 'Z' && s[i] != 'I')\n            s[i] += 32;\n        // 将问号替换为感叹号\n        if (s[i] == '?')\n            s[i] = '!';\n    }\n    processed += s;\n    processed += \" \"; // 后面添加空格以删除字符串末尾的空格\n    s.clear();\n    s += \" \";\n    // 去除连续的空格和标点符号前的空格\n    for (int i = 1; i < processed.length() - 1; i++) {\n        if (processed[i] == ' ' && processed[i - 1] == ' ') // 去除连续的空格\n            continue;\n        else if (check(processed[i + 1]) == 5 && processed[i] == ' ') // 标点前的空格要删除\n            continue;\n        else\n            s += processed[i];\n    }\n    s += \" \";\n    return s;\n}\n \nint main() {\n    int n; // 输入语句数量\n    cin >> n;\n    cin.ignore(); // 忽略换行符\n    for (int i = 0; i < n; i++) {\n        string input;\n        getline(cin, input);\n        cout << input << endl;\n        cout << \"AI: \";\n        bool hasContent = false; // 是否有内容\n        int charCount = 0; // 字符计数\n        // 检查是否全为空格\n        for (int j = 0; j < input.size(); j++) {\n            if (input[j] != ' ') {\n                hasContent = true;\n                break;\n            }\n        }\n        if (!hasContent) {\n            cout << endl;\n            continue;\n        }\n        input = processInput(input); // 处理输入字符串\n        string processed;\n        for (int j = 0; j < input.size(); j++) {\n            processed += input[j];\n            // 替换'me'为'you'\n            if (check(input[j]) > 3 && input[j + 1] == 'm' && input[j + 2] == 'e' && check(input[j + 3]) > 3) {\n                j += 2;\n                processed += \"you\";\n            }\n            // 替换'I'为'you'\n            else if (check(input[j]) > 3 && input[j + 1] == 'I' && check(input[j + 2]) > 3) {\n                j++;\n                processed += \"you\";\n            }\n            // 替换'can you'为'I can'\n            else if (check(input[j]) > 3 && input[j + 1] == 'c' && input[j + 2] == 'a' && input[j + 3] == 'n' &&\n                     input[j + 5] == 'y' && input[j + 6] == 'o' && input[j + 7] == 'u' && check(input[j + 8]) > 3) {\n                j += 7;\n                processed += \"I can\";\n            }\n            // 替换'could you'为'I could'\n            else if (check(input[j]) > 3 && input[j + 1] == 'c' && input[j + 2] == 'o' && input[j + 3] == 'u' &&\n                     input[j + 4] == 'l' && input[j + 5] == 'd' && input[j + 7] == 'y' && input[j + 8] == 'o' &&\n                     input[j + 9] == 'u' && check(input[j + 10]) > 3) {\n                j += 9;\n                processed += \"I could\";\n            }\n        }\n        input = \"\";\n        input += processed;\n        int lastValidIndex;\n        // 找到最后一个空格的前一个有效字符下标\n        for (int j = input.length() - 1; j >= 0; j--) {\n            if (input[j] != ' ') {\n                lastValidIndex = j;\n                break;\n            }\n        }\n        // 输出处理后的字符串\n        for (int j = 0; j <= lastValidIndex; j++) {\n            if (j > 0 && input[j] == ' ' && check(input[j + 1]) == 5)\n                continue;\n            if (input[j] != ' ') {\n                cout << input[j];\n                charCount++;\n            } else if (charCount > 0)\n                cout << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731393": {
        "problemSetProblemId": "1767420176117731393",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "Talk is cheap. Show me the code."
        },
        "problemId": "0"
    },
    "1767420176117731394": {
        "problemSetProblemId": "1767420176117731394",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint main() {\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tcout << a*b*c;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731395": {
        "problemSetProblemId": "1767420176117731395",
        "programmingSubmissionDetail": {
            "compiler": "PYTHON3",
            "program": "s = input().split()\nr = float(s[0])\n \nif s[1] == '0':\n    r *= 2.455\nelse:\n    r *= 1.26\nprint('%.2f' % r, end=' ')\n \nif r < float(s[2]):\n    print('^_^')\nelse:\n    print('T_T')"
        },
        "problemId": "0"
    },
    "1767420176117731396": {
        "problemSetProblemId": "1767420176117731396",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include <stdio.h>\nint main()\n{\n    int n,i;\n    float a,sum=0;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {scanf(\"%f\",&a);\n     sum+=1/a;\n    }\n    printf(\"%.2f\",1/(sum/n));\n    return 0;\n}\n\n"
        },
        "problemId": "0"
    },
    "1767420176117731397": {
        "problemSetProblemId": "1767420176117731397",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint a[4];\n\tint max=0;\n\tfor(int i=0; i<4; i++) {\n\t\tcin>>a[i];\n\t\tif(max<a[i])\n\t\t\tmax=a[i];\n\t}\n\tint x,y;//最低报警胎压 胎压差的阈值\n\tcin>>x>>y;\n\tint cnt=0;\n\tint s;\n\tfor(int i=0; i<4; i++) {\n\t\tif(max-a[i]>y||a[i]<x) {\n\t\t\tcnt++;//记录不合格的个数\n\t\t\ts=i;//记录当前的序号\n\t\t}\n\t}\n\tif(cnt==0)\n\t\tcout<<\"Normal\\n\";\n\telse if(cnt==1)\n\t\tcout<<\"Warning: please check #\"<<s+1<<\"!\\n\";\n\telse\n\t\tcout<<\"Warning: please check all the tires!\\n\";\n\n\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731398": {
        "problemSetProblemId": "1767420176117731398",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n   int count=0;\n    string s[1000];\n    int i=0;\n    getline(cin,s[i++]);\n    while(s[i-1].compare(\".\")!=0){\n        getline(cin,s[i++]);\n    }\n    cout<<i-1<<endl;\n    for(int j=0;j<i-1;j++){\n        if(s[j].find(\"chi1 huo3 guo1\")!=s[j].npos){\n            count++;\n            if(count==1)\n                cout<<j+1<<\" \";\n        }\n    }\n    if(count==0)\n        cout<<\"-_-#\";\n    else\n        cout<<count;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731399": {
        "problemSetProblemId": "1767420176117731399",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string s[m];\n    for(int i=0;i<m;i++){\n        cin>>s[i];\n    }\n    int min=1;\n    int max=1;\n    min=1*pow(2,n);\n    for(int i=0;i<n;i++){\n        max=max*2+1;\n    }\n    for(int i=0;i<m;i++){\n        int weizhi=1;\n        for(int j=0;j<n;j++){\n            if(s[i][j]=='y')\n                weizhi=weizhi*2;\n            else\n                weizhi=weizhi*2+1;\n        }\n        cout<<weizhi-min+1<<endl;\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731400": {
        "problemSetProblemId": "1767420176117731400",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(){\n    int a[4][4];\n    int b[10]={0};\n    int hang,lie;//记录0的位置\n    for(int i=1;i<4;i++){\n        for(int j=1;j<4;j++){\n            cin>>a[i][j];\n            b[a[i][j]]=1;\n            if(a[i][j]==0){\n                hang=i;\n                lie=j;\n            }\n        }\n    }\n    for(int i=0;i<10;i++){\n        if(b[i]==0){\n            a[hang][lie]=i;\n            break;\n        }\n    }\n    for(int i=0;i<3;i++){\n        int t1,t2;\n        cin>>t1>>t2;\n        cout<<a[t1][t2]<<endl;\n    }\n    int total=0;\n    int choice;\n    cin>>choice;\n    if(choice==1){\n        total=a[1][1]+a[1][2]+a[1][3];\n    }\n    else if(choice==2)\n        total=a[2][1]+a[2][2]+a[2][3];\n    else if(choice==3)\n        total=a[3][1]+a[3][2]+a[3][3];\n    else if(choice==4)\n        total=a[1][1]+a[2][1]+a[3][1];\n    else if(choice==5)\n        total=a[1][2]+a[2][2]+a[3][2];\n    else if(choice==6)\n        total=a[1][3]+a[2][3]+a[3][3];\n    else if(choice==7)\n        total=a[1][1]+a[2][2]+a[3][3];\n    else if(choice==8)\n        total=a[1][3]+a[2][2]+a[3][1];\n    if(total==6)\n        cout<<10000;\n    else if(total==7)\n        cout<<36;\n    else if(total==8)\n        cout<<720;\n    else if(total==9)\n        cout<<360;\n    else if(total==10)\n        cout<<80;\n    else if(total==11)\n        cout<<252;\n    else if(total==12)\n        cout<<108;\n    else if(total==13)\n        cout<<72;\n    else if(total==14)\n        cout<<54;\n    else if(total==15)\n        cout<<180;\n    else if(total==16)\n        cout<<72;\n    else if(total==17)\n        cout<<180;\n    else if(total==18)\n        cout<<119;\n    else if(total==19)\n        cout<<36;\n    else if(total==20)\n        cout<<306;\n    else if(total==21)\n        cout<<1080;\n    else if(total==22)\n        cout<<144;\n    else if(total==23)\n        cout<<1800;\n    else if(total==24)\n        cout<<3600;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731401": {
        "problemSetProblemId": "1767420176117731401",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "To iterate is human, to recurse divine."
        },
        "problemId": "0"
    },
    "1767420176117731402": {
        "problemSetProblemId": "1767420176117731402",
        "programmingSubmissionDetail": {
            "compiler": "PYTHON3",
            "program": "a=input().split()\nfor i in range(3):\n    a[i]=int(a[i])\nprint(str(a[0]-a[1]*a[2]))"
        },
        "problemId": "0"
    },
    "1767420176117731403": {
        "problemSetProblemId": "1767420176117731403",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(){\n    string s;\n    cin>>s;\n    int n=0;\n    if(s.length()==6)\n        cout<<s.substr(0,4)<<\"-\"<<s.substr(4,2);\n    else{\n        n=(s[0]-'0')*10+s[1]-'0';\n        if(n<22)\n            cout<<\"20\"<<s[0]<<s[1]<<\"-\"<<s[2]<<s[3];\n        else\n            cout<<\"19\"<<s[0]<<s[1]<<\"-\"<<s[2]<<s[3];\n    }\n}\n "
        },
        "problemId": "0"
    },
    "1767420176117731404": {
        "problemSetProblemId": "1767420176117731404",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n    int n;\n    int jiage;\n    scanf(\"%d %d\",&n,&jiage);\n    for(int i=0;i<n;i++){\n        float b;\n        scanf(\"%f\",&b);\n        if(b<jiage)\n            printf(\"On Sale! %.1f\\n\",b);\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731405": {
        "problemSetProblemId": "1767420176117731405",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n    int xinq[24];\n    for(int i=0;i<24;i++){\n        scanf(\"%d\",&xinq[i]);\n    }\n    int n;\n    scanf(\"%d\",&n);\n    while(n>=0&&n<=23){\n        printf(\"%d \",xinq[n]);\n        if(xinq[n]>50)\n            printf(\"Yes\\n\");\n        else\n            printf(\"No\\n\");\n        scanf(\"%d\",&n);\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731406": {
        "problemSetProblemId": "1767420176117731406",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(){\n    int n;\n    int zuo;\n    int sum=0;\n    cin>>n>>zuo;\n    getchar();\n    string s[n];\n    for(int i=0;i<n;i++){\n        getline(cin,s[i]);\n    }\n    for(int i=0;i<n;i++){\n        if(s[i].find(\"qiandao\")!=s[i].npos||s[i].find(\"easy\")!=s[i].npos)\n            continue;\n        else{\n            sum++;\n            if(sum==zuo){\n                int f=0;\n                for(int j=i+1;j<n;j++){\n                    if(s[j].find(\"qiandao\")==s[j].npos&&s[j].find(\"easy\")==s[j].npos){\n                        cout<<s[j];\n                        f=1;\n                        break;\n                    }\n                }\n                if(f==0)\n                    cout<<\"Wo AK le\";\n                break;\n            }\n        }\n    }\n    if(sum<zuo)\n        cout<<\"Wo AK le\";\n}"
        },
        "problemId": "0"
    },
    "1767420176117731407": {
        "problemSetProblemId": "1767420176117731407",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    int a[n];\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    int min=10000000;\n    int max=-1;\n    for(int i=0;i<n;i++){\n        if(a[i]<min)\n            min=a[i];\n        if(a[i]>max)\n            max=a[i];\n    }\n    int minr=0;\n    int maxr=0;\n    for(int i=0;i<n;i++){\n        if(a[i]==min)\n            minr++;\n        if(a[i]==max)\n            maxr++;\n    }\n    cout<<min<<\" \"<<minr<<endl;\n    cout<<max<<\" \"<<maxr<<endl;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731408": {
        "problemSetProblemId": "1767420176117731408",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,l=0,t;\n    string s,s1,s2;\n    cin>>s1>>s2>>n;\n    s=s1+s2;\n    while(s.size()<=n){\n        s1=s[l];\n        s2=s[l+1];\n        t=stoi(s1)*stoi(s2);\n        s+=to_string(t);\n        l++;\n    }\n    for(int i=0;i<n;i++){\n        cout<<s[i];\n        if(i!=n-1){\n            cout<<\" \";\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731409": {
        "problemSetProblemId": "1767420176117731409",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "I'm gonna win! Today!\n2022-04-23"
        },
        "problemId": "0"
    },
    "1767420176117731410": {
        "problemSetProblemId": "1767420176117731410",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n    int a1,a2;\n    scanf(\"%d %d\",&a1,&a2);\n    printf(\"%d\",a1/a2);\n}"
        },
        "problemId": "0"
    },
    "1767420176117731411": {
        "problemSetProblemId": "1767420176117731411",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n    int min;\n    int pei;\n    int a1;\n    int a2;\n    scanf(\"%d %d %d %d\",&min,&pei,&a1,&a2);\n    if(a1<min&&a2<min){\n        printf(\"%d-N %d-N\\n\",a1,a2);\n        printf(\"zhang da zai lai ba\");\n    }\n    else if(a1>=min&&a2>=min){\n        printf(\"%d-Y %d-Y\\n\",a1,a2);\n        printf(\"huan ying ru guan\");\n    }\n    else if(a1>=min&&a2<min){\n        if(a1>=pei){\n            printf(\"%d-Y %d-Y\\n\",a1,a2);\n            printf(\"qing 1 zhao gu hao 2\");\n        }\n        else{\n            printf(\"%d-Y %d-N\\n\",a1,a2);\n            printf(\"1: huan ying ru guan\");\n        }\n    }\n    else if(a1<min&&a2>=min){\n        if(a2>=pei){\n            printf(\"%d-Y %d-Y\\n\",a1,a2);\n            printf(\"qing 2 zhao gu hao 1\");\n        }\n        else{\n            printf(\"%d-N %d-Y\\n\",a1,a2);\n            printf(\"2: huan ying ru guan\");\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731412": {
        "problemSetProblemId": "1767420176117731412",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    int sum=1;\n    for(int i=1;i<=a+b;i++){\n        sum=sum*i;\n    }\n    printf(\"%d\",sum);\n}"
        },
        "problemId": "0"
    },
    "1767420176117731413": {
        "problemSetProblemId": "1767420176117731413",
        "programmingSubmissionDetail": {
            "compiler": "JAVAC",
            "program": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n \n        int[] init = new int[6];\n        int[] original = new int[6];\n        for (int i = 0; i < 6; i++) {\n            init[i] = sc.nextInt();\n            original[i] = init[i];\n        }\n \n        int n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 6; j++) {\n                if (i == 0) {\n                    if (init[j] != 6) {\n                        init[j] = 6;\n                    } else {\n                        init[j]--;\n                    }\n                } else {\n                    if (init[j] - 1 == original[j]) {\n                        init[j] = init[j] - 2;\n                    } else {\n                        init[j]--;\n                    }\n                }\n            }\n        }\n \n        for (int i = 0; i < 6; i++) {\n            if (i < 5) {\n                System.out.print(init[i] + \" \");\n            } else {\n                System.out.print(init[i]);\n            }\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731414": {
        "problemSetProblemId": "1767420176117731414",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<ctype.h>\n#include<stdio.h>\nusing namespace std;\n \nint main(){\n\tstring a1,a2,s1=\"\",s2=\"\";\n\tgetline(cin,a1);\n\tgetline(cin,a2);\n\tfor(int i=1;i<(int)a1.size();i++){\n\t  \tif((a1[i]-'0')%2==(a1[i-1]-'0')%2){\n\t\t\ts1+=max(a1[i],a1[i-1]);\n\t  }\n\t}\n\tfor(int i=1;i<(int)a2.size();i++){\n\t\tif((a2[i]-'0')%2==(a2[i-1]-'0')%2){\n\t\t\ts2+=max(a2[i],a2[i-1]);\n\t\t}\n\t}\n\tif(s1==s2) cout<<s1;\n\telse cout<<s1<<endl<<s2;\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731415": {
        "problemSetProblemId": "1767420176117731415",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(){\n    int n,m,q;\n    cin>>n>>m>>q;\n    int a[n+1][m+1];\n    for(int i=0;i<n+1;i++){\n        for(int j=0;j<m+1;j++){\n            a[i][j]=0;\n        }\n    }\n    for(int i=0;i<q;i++){\n        int a1,a2;\n        cin>>a1>>a2;\n        if(a1==0){\n            for(int j=1;j<m+1;j++){\n                a[a2][j]=1;\n            }\n        }\n        else{\n            for(int j=1;j<n+1;j++){\n                a[j][a2]=1;\n            }\n        }\n    }\n    int sum=m*n;\n    for(int i=1;i<n+1;i++){\n        for(int j=1;j<m+1;j++){\n            if(a[i][j]==1)\n                sum--;\n        }\n    }\n    cout<<sum;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731416": {
        "problemSetProblemId": "1767420176117731416",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint n,s,k;\nint a[291]={0};     //用于记录同一个分数有多少人 \nint main(){\n    cin>>n>>k>>s;\n    int ans=0;\n    while(n--){\n        int t,p;\n        cin>>t>>p;\n          if(t>=175){//这些人可以直接录取\n            if(p>=s)\n            ans++;\n            else{\n                a[t]++;\n            }\n        } \n    }\n    for(int i=175;i<=290;i++){\n        if(a[i]>=k)\n            ans=ans+k;\n        else\n            ans+=a[i];\n    }\n    cout<<ans;\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731417": {
        "problemSetProblemId": "1767420176117731417",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, c1, c2;\nint dis[510], weight[510], e[510][510], num[510], w[510], pre[510];\nbool visit[510];\nconst int inf = 99999999;\nvoid printPath(int v) {\n    if(v == c1) {\n        printf(\"%d\", v);\n        return ;\n    }\n    printPath(pre[v]);\n    printf(\" %d\", v);\n}\nint main() {\n    scanf(\"%d%d%d%d\", &n, &m, &c1, &c2);\n    for(int i = 0; i < n; i++)\n        scanf(\"%d\", &weight[i]);\n    fill(e[0], e[0] + 510 * 510, inf);\n    fill(dis, dis + 510, inf);\n    int a, b, c;\n    for(int i = 0; i < m; i++) {\n        scanf(\"%d%d%d\", &a, &b, &c);\n        e[a][b] = c;\n        e[b][a] = c;\n    }\n    dis[c1] = 0;\n    w[c1] = weight[c1];\n    num[c1] = 1;\n    for(int i = 0; i < n; i++) {\n        int u = -1, minn = inf;\n        for(int j = 0; j < n; j++) {\n            if(visit[j] == false && dis[j] < minn) {\n                u = j;\n                minn = dis[j];\n            }\n        }\n        if(u == -1) break;\n        visit[u] = true;\n        for(int v = 0; v < n; v++) {\n            if(visit[v] == false && e[u][v] != inf) {\n                if(dis[u] + e[u][v] < dis[v]) {\n                    dis[v] = dis[u] + e[u][v];\n                    num[v] = num[u];\n                    w[v] = w[u] + weight[v];\n                    pre[v] = u;\n                } else if(dis[u] + e[u][v] == dis[v]) {\n                    num[v] = num[v] + num[u];\n                    if(w[u] + weight[v] > w[v]) {\n                        w[v] = w[u] + weight[v];\n                        pre[v] = u;\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d %d\\n\", num[c2], w[c2]);\n    printPath(c2);\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731418": {
        "problemSetProblemId": "1767420176117731418",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 1e5;\nstruct Node{\n    int address;\n    int key;\n    int next;\n    int num;\n}node[maxn];\nbool vis[maxn];\nbool cmp(Node a,Node b){\n    return a.num<b.num;\n}\nint main()\n{\n    int head,n,a;\n    scanf(\"%d%d\",&head,&n);\n    int k1=0,k2=0;\n    for(int i=0;i<maxn;i++){\n        node[i].num=2*maxn;\n    }\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&a);\n        scanf(\"%d%d\",&node[a].key,&node[a].next);\n        node[a].address=a;\n             }\n    for(int i=head;i!=-1;i=node[i].next){\n        if(!vis[abs(node[i].key)]){\n            vis[abs(node[i].key)]=true;\n            node[i].num=k1;\n            k1++;\n        }else{\n            node[i].num=maxn+k2;\n            k2++;\n        }\n    }\n    sort(node,node+maxn,cmp);\n    int k=k1+k2;\n    for(int i=0;i<k;i++){\n        if(i!=k1-1&&i!=k-1){\n            printf(\"%05d %d %05d\\n\",node[i].address,node[i].key,node[i+1].address);\n        }else{\n            printf(\"%05d %d -1\\n\",node[i].address,node[i].key);\n        }\n    }\n    return 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731419": {
        "problemSetProblemId": "1767420176117731419",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef struct kc{\n    float kcl,zsj;\n    float dj;\n}Yb;\nfloat sum=0.0;\nYb yb[1010];\nbool cmp(Yb a,Yb b){\n    return a.dj>b.dj;\n}\nint main(){\n    int n,d;\n    float zkc=0;\n    cin>>n>>d;\n    for(int i=0;i<n;i++){\n        cin>>yb[i].kcl;\n        zkc+=yb[i].kcl;\n    }\n    for(int i=0;i<n;i++){\n        cin>>yb[i].zsj;\n        yb[i].dj=1.0*yb[i].zsj/yb[i].kcl;\n    }\n    sort(yb,yb+n,cmp);\n    if(zkc<=d){\n        float sj=0;\n        for(int i=0;i<n;i++){\n            sj+=yb[i].zsj;\n        }\n        printf(\"%.2f\",sj);\n    }else{\n        int j=0;\n        while(d>yb[j].kcl){\n            d-=yb[j].kcl;\n            sum+=yb[j].zsj;\n            j++;\n        }\n        sum+=yb[j].dj*d;\n        printf(\"%.2f\",sum);\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731420": {
        "problemSetProblemId": "1767420176117731420",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 1e3+10;\nint nums[maxn];\nvector<int>q;\nint flag;\nvoid get_post(int l,int r){\n    if(l>r)return ;\n    int i = l+1,j=r;\n    if(!flag)//不是镜像\n    {\n        while(i<=r&&nums[i]<nums[l])i++;\n        while(j>l&&nums[j]>=nums[l])j--;\n \n    }\n    else{\n         while(i<=r&&nums[i]>=nums[l])i++;\n        while(j>l&&nums[j]<nums[l])j--;\n    }\n    if(i-j!=1)return;\n    get_post(l+1,j);\n    get_post(i,r);\n    q.push_back(nums[l]);\n}\nint main(){\n \n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>nums[i];\n \n    }\n    get_post(1,n);\n \n    if(q.size()!=n){\n        flag=1;\n        q.clear();\n        get_post(1,n);\n    }\n \n    if(q.size()==n)\n\t{\n\t\tprintf(\"YES\\n\");\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tprintf(\"%d\",q[i]);\n\t\t\tif(i<n-1) printf(\" \");\n\t\t} \n\t}\n\telse printf(\"NO\\n\");\n\treturn 0;\n \n \n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731421": {
        "problemSetProblemId": "1767420176117731421",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<set>\n#include<vector>\nusing namespace std;\nconst int MAXV = 50;\nvector<set<int>> cnt;\nvoid dowork(int a, int b)\n{\n    int  Nc=0,Nt=cnt[b-1].size();\n    for (auto it = cnt[a - 1].begin(); it != cnt[a - 1].end(); it++) {\n        if (cnt[b - 1].find(*it) == cnt[b - 1].end())\n            Nt++;\n        else\n            Nc++;\n    }\n    double ans = (Nc * 1.0) / Nt * 100;\n    printf(\"%.2f%%\\n\", ans);\n}\nint main()\n{\n    int N; cin >> N;\n    for (int i = 0; i < N; i++) {\n        int M; cin >> M;\n        set<int> LS;\n        for (int j = 0; j < M; j++) {\n            int a; cin >> a;\n            LS.insert(a);\n        }\n        cnt.push_back(LS);\n    }\n    int K;cin >> K;\n    while (K--)\n    {\n        int a, b;\n        cin >> a >> b;\n        dowork(a, b);\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731422": {
        "problemSetProblemId": "1767420176117731422",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef struct node {\n\tint data;\n\tstruct node* rchild, * lchild;\n}leaf;\n\nvector<int > teil, ind;\nleaf *tree;\n\nvoid recover(leaf **root,int start1,int end1,int start2,int end2) {//还原二叉树\n\tint leng;\n\tif (end1 < start1||end2<start2) {\n\t\t*root = NULL;\n\t\treturn;\n\t}\n\t*root = new leaf;\n\t(*root)->data = teil[end1];\n\tfor (int i = start2; i <= end2; i++) {\n\t\tif (ind[i] == teil[end1]) {\n\t\t\tleng = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\trecover(&((*root)->lchild), start1, start1 + leng - start2 -1, start2, leng-1);\n\trecover(&((*root)->rchild), start1 + leng - start2 , end1 - 1, leng + 1, end2);\n}\n\nint main() {\n\tint num;\n\tcin >> num;\n\tfor (int i = 0; i < num; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tteil.push_back(x);\n\t}\n\tfor (int i = 0; i < num; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tind.push_back(x);\n\t}\n\trecover(&tree,0,num-1,0,num-1);\n\tvector<int> ouput;\n\tqueue<leaf*> line;\n\tline.push(tree);\n\twhile (!line.empty()) {//队列层次遍历二叉树\n\t\tleaf* p;\n\t\tp = line.front();\n\t\touput.push_back(p->data);\n\t\tline.pop();\n\t\tif (p->lchild != NULL)\n\t\t\tline.push(p->lchild);\n\t\tif (p->rchild != NULL)\n\t\t\tline.push(p->rchild);\n\t}\n\tcout << ouput[0];\n\tfor (int i = 1; i < num; i++) {\n\t\tcout << \" \"<<ouput[i];\n\t}\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731423": {
        "problemSetProblemId": "1767420176117731423",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct node {\n\tint id;\n\tint numHouse, spaceHouse;\n\tint numPeople;\n}people[10000];\n\nbool flag[10000];\n\nstruct fam {\n\tint sumNum, sumSpace,sumPeople;\n\tfloat avgNum, avgSpace;\n\tint id;\n}fam[10000];\n\nint fa[10000];\n\nint find(int x) {\n\treturn fa[x] == x ? x : find(fa[x]);\n}\n\nvoid unin(int a, int b) {\n\tint x=find(a), y=find(b);\n\tif (x == y)\n\t\treturn;\n\tif (x < y)\n\t\tfa[y] = x;\n\telse\n\t\tfa[x] = y;\n}\n\nbool cmp(struct fam x, struct fam y) {\n\tif (x.avgSpace > y.avgSpace)\n\t\treturn true;\n\telse if(x.avgSpace < y.avgSpace)\n\t\treturn false;\n\telse {\n\t\tif (x.id >= y.id)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n}\n\nint main() {\n\tint num;\n\tcin >> num;\n\n\tfor (int i = 0; i < 10000; i++) {\n\t\tfa[i] = i;\n\t}\n\n\tfor (int i = 0; i < num; i++) {\n\t\tint fa, ma;\n\t\tcin >> people[i].id >> fa >> ma;\n\t\tflag[people[i].id] = true;\n\t\tif (fa != -1) {\n\t\t\tunin(fa, people[i].id);\n\t\t\tflag[fa] = true;\n\t\t}\n\t\tif (ma != -1) {\n\t\t\tunin(ma, people[i].id);\n\t\t\tflag[ma] = true;\n\t\t}\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint child;\n\t\t\tcin >> child;\n\t\t\tunin(child, people[i].id);\n\t\t\tflag[child] = true;\n\t\t}\n\t\tint numHouse, spaceHouse;\n\t\tcin >> numHouse >> spaceHouse;\n\t\tpeople[i].numHouse = numHouse;\n\t\tpeople[i].spaceHouse = spaceHouse;\n\t}\n\n\tfor (int i = 0; i < num; i++) {//将所有信息统一到root结点\n\t\tint k = find(people[i].id);\n\t\tfam[k].sumNum += people[i].numHouse;\n\t\tfam[k].sumSpace += people[i].spaceHouse;\n\t\tfam[k].id = k;\n\t}\n\n\tfor (int i = 0; i < 10000; i++) {//统计每个家庭的人数\n\t\tif (flag[i]) {\n\t\t\tint k = find(i);\n\t\t\tfam[k].sumPeople++;\n\t\t}\n\t}\n\tint family=0;\n\tfor (int i = 0; i < 10000; i++) {//统计家庭的数量并结算平均值\n\t\tif (fam[i].sumPeople != 0) {\n\t\t\tfam[i].avgNum = 1.0 * fam[i].sumNum / fam[i].sumPeople;\n\t\t\tfam[i].avgSpace = 1.0 * fam[i].sumSpace / fam[i].sumPeople;\n\t\t\tfamily++;\n\t\t}\n\t}\n\tsort(fam, fam + 9999, cmp);\n\tcout << family << endl;\n\tfor (int i = 0; i < family; i ++ ) {\n\t\tprintf(\"%04d %d %.3f %.3f\\n\", fam[i].id, fam[i].sumPeople, fam[i].avgNum, fam[i].avgSpace);\n\t}\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176117731424": {
        "problemSetProblemId": "1767420176117731424",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    string s,x,fx;\n    int ma=0;\n    getline(cin,s);\n    for(int i=0;i<s.size()-1;i++){\n        for(int j=i+1;j<=s.size();j++){\n            x=s.substr(i,j-i);\n            fx=x;\n            reverse(x.begin(),x.end());\n            if(x==fx){\n                if(ma<x.size()){\n                    ma=x.size();\n                }\n            }\n        }\n    }\n    if(s.size()==1){\n        ma=1;\n    }\n    cout<<ma;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731425": {
        "problemSetProblemId": "1767420176117731425",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nstruct ren{\n    int bh;\n    double money=0.0;\n    int count=0;\n}r[10010];\nbool cmp(const struct ren r1,const struct ren r2){\n    if(abs(r1.money-r2.money)>=0.01){\n        return r1.money>r2.money;\n    }else if(abs(r1.count!=r2.count)>=0.01){\n        return r1.count>r2.count;\n    }else{\n        return r1.bh<r2.bh;\n    }\n}\nint main(){\n    int n,m,x,y;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        r[i].bh=i+1;\n    }\n    for(int i=0;i<n;i++){\n        cin>>m;\n        for(int j=0;j<m;j++){\n            cin>>x>>y;\n            r[i].money-=(y*1.0/100);\n            r[x-1].money+=(y*1.0/100);\n            r[x-1].count++;\n        }\n    }\n    sort(r,r+n,cmp);\n    for(int i=0;i<n;i++){\n        printf(\"%d %.2lf\\n\",r[i].bh,r[i].money);\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176117731426": {
        "problemSetProblemId": "1767420176117731426",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "/*   一切都是命运石之门的选择  El Psy Kongroo  */\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<cmath>\n#include<functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<double, double> pdd;\ntypedef pair<string, int> psi;\ntypedef __int128 int128;\n#define PI acos(-1.0)\n#define x first\n#define y second\n//int dx[4] = {1, -1, 0, 0};\n//int dy[4] = {0, 0, 1, -1};\nconst int inf = 0x3f3f3f3f, mod = 1e9 + 7;\n\nconst int N = 110;\nint fa[N], n, m, q;\nbool g[N][N];   //存储敌对关系\n\nint find(int x){\n    return fa[x] == x ? x : (fa[x] = find(fa[x]));\n}\n\nvoid Union(int u, int v){\n    int fu = find(u), fv = find(v);\n    if(fu == fv) return;\n    fa[fv] = fu;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    cin >> n >> m >> q;\n    for(int i = 1; i <= n; i ++ ) fa[i] = i;\n    while(m -- ){\n        int u, v, c; cin >> u >> v >> c;\n        if(c == 1) Union(u, v);\n        else g[u][v] = g[v][u] = true;   //只需要存储单纯的敌对关系 无序扩展并查集\n    }\n\n    while(q -- ){\n        int u, v; cin >> u >> v;\n        int fu = find(u), fv = find(v);\n        if(fu == fv){\n            if(g[u][v]) cout << \"OK but...\" << endl;  //有共同朋友但敌对\n            else cout << \"No problem\" << endl;        //有共同朋友且不敌对\n        }else{\n            if(g[u][v]) cout << \"No way\" << endl;     //无共同朋友但敌对\n            else cout << \"OK\" << endl;                //无共同朋友 不敌对\n        } \n    }\n\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176117731427": {
        "problemSetProblemId": "1767420176117731427",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include<stdio.h>\n#include <vector>\n#define N 31\nusing namespace std;\nint a[N],b[N];\nvector<int> ve(100000,-1);\nvoid build(int x,int y,int root,int step)/**x,y为左子树或右子树的区间，root为根节点，step为当前根节点的位置（满二叉树）*/\n{\n    if(x>y) return;\n    ve[step]=a[root];/**记录当前根节点的位置*/\n    int i;\n    for(i=x;i<=y;++i){\n        if(a[root]==b[i])\n            break;\n    }\n    build(i+1,y,root+(i-x)+1,step*2+1);\n    build(x,i-1,root+1,step*2+2);\n    /**镜面这个其实就只要在递归的时候先递归右树，再递归左树就好*/\n}\nint main()\n{\n    int n;cin>>n;\n    for(int i=1;i<=n;++i)\n        cin>>b[i];\n    for(int i=1;i<=n;++i)\n        cin>>a[i];\n    build(1,n,1,0);\n    int cnt=0;\n    for(int i=0;i<ve.size()&&cnt<=n;++i){\n\n        if(ve[i]!=-1){\n            if(i)\n               cout<<\" \";\n            cout<<ve[i];\n            ++cnt;\n        }\n    }\n    return 0;\n}\n\n"
        },
        "problemId": "0"
    },
    "1767420176117731428": {
        "problemSetProblemId": "1767420176117731428",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1010;\nint h[N];\nint n,m;\nmap<int,int> mp;\nvoid heap_swap(int a,int b)\n{\n    swap(h[a],h[b]);\n}\nvoid up(int x)\n{\n    while(x/2 && h[x/2]>h[x])\n    {\n        heap_swap(x/2,x);\n        x/=2;\n    } \n}\nint main()\n{\n   cin>>n>>m;\n   for(int i=1;i<=n;i++)\n    {\n        cin>>h[i];\n        up(i);\n    } \n    for(int i=1; i<=n; i++) mp[h[i]]=i;\n    //for(int i=n/2;i;i--) down(i);\n    //for(int i=1;i<=len;i++) cout<<h[i]<<\" \";\n    string s;\n    int x,y;\n    while(m--)\n    {\n        cin>>x;\n        cin>>s;\n        if(s[0]=='a')       //x and y are siblings\n        {\n            cin>>y;\n            getline(cin,s);\n            if(mp[x]/2==mp[y]/2) puts(\"T\");\n            else puts(\"F\");\n        }\n        else\n        {\n            cin>>s;\n            cin>>s;\n            if(s[0]=='r')   //x is the root\n            {\n                if(mp[x]==1) puts(\"T\");\n                else puts(\"F\");\n            }\n            else if(s[0]=='p')  //x is the parent of y\n            {\n                cin>>s;\n                cin>>y;\n                if(mp[x]==mp[y]/2) puts(\"T\");\n                else puts(\"F\");\n            }\n            else    //x is a child of y\n            {\n                cin>>s;\n                cin>>y;\n                if(mp[x]/2==mp[y]) puts(\"T\");\n                else puts(\"F\");\n            }\n        }\n    }\n    return 0; \n}\n\n作者：GRID\n链接：https://www.acwing.com/solution/content/21404/\n来源：AcWing\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
        },
        "problemId": "0"
    },
    "1767420176117731429": {
        "problemSetProblemId": "1767420176117731429",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nint n, m, k, u;\nint father[505], vis[505];\nstruct node\n{\n    int a, b;\n} road[5005];\nint count() //通过并查集查找连通分支数\n{\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (father[i] == i && vis[i] == 0)\n            count++;\n    return count;\n}\nvoid init()\n{\n    for (int i = 0; i < 505; i++)\n        father[i] = i;\n}\nint find(int x)\n{\n    int t = x;\n    while (t != father[t])\n    {\n        t = father[t];\n    }\n    return t;\n}\nvoid Union(int x, int y)\n{\n    int fx = find(x);\n    int fy = find(y);\n    if (fx != fy)\n        father[fy] = fx;\n}\nint main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    init();\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        road[i].a = a;\n        road[i].b = b;\n        Union(a, b);\n    }\n    int sum = count();\n    cin >> k;\n    for (int t = 0; t < k; t++)\n    {\n        cin >> u;\n        vis[u] = 1;\n        init();\n        for (int i = 0; i < m; i++)\n        {\n            int a = road[i].a;\n            int b = road[i].b;\n            if (vis[a] == 0 && vis[b] == 0)\n                Union(a, b);\n        }\n \n        int cur = count();\n        if (cur <= sum)\n            printf(\"City %d is lost.\\n\", u);\n        else\n            printf(\"Red Alert: City %d is lost!\\n\", u);\n \n        sum = cur;\n    }\n    if (n == k)\n        printf(\"Game Over.\\n\");\n \n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925632": {
        "problemSetProblemId": "1767420176121925632",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tint root[n];\n\tint len = 0;\n\tint k;\n\twhile(n--){\n\t\tcin>>k;\n\t\tif(len == 0 || root[len-1] < k){\n\t\t\troot[len++] = k;\n\t\t}else{\n\t\t\t//折半查找法 \n\t\t\tint one = 0,two = len-1;\n\t\t\twhile(one < two){\n\t\t\t\tint mid = one + (two-one)/2;\n\t\t\t\tif(root[mid] > k){\n\t\t\t\t\ttwo = mid - 1;\n\t\t\t\t}else{\n\t\t\t\t\tone = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\troot[one] = k;\n\t\t/*\t//普通 顺序 查找,因为排列是按顺序的，所以也可以按顺序查找，但是当数据过多时，容易超时 \n\t\t\tfor(int i=0;i<=len-1;i++){\n\t\t\t\tif(root[i] > k){\n\t\t\t\t\troot[i] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t*/\n\t\t}\n\t}\n\tcout<<len;\n\treturn 0;\n} \n"
        },
        "problemId": "0"
    },
    "1767420176121925633": {
        "problemSetProblemId": "1767420176121925633",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k,m;\n    double fsh,fs,mif,maf;\n    double s[10010];\n    cin>>n>>k>>m;\n    for(int i=0;i<n;i++){\n        fsh=0;\n        mif=100;\n        maf=0;\n        for(int j=0;j<k;j++){\n            cin>>fs;\n            fsh+=fs;\n            mif=min(fs,mif);\n            maf=max(fs,maf);\n        }\n        fsh-=mif;\n        fsh-=maf;\n        s[i]=fsh*1.0/(k-2);\n    }\n    sort(s,s+n,greater<double>());\n    for(int i=m-1;i>=0;i--){\n        if(i!=m-1){\n            cout<<\" \";\n        }\n        printf(\"%.3lf\",s[i]);\n    }\n    cout<<endl;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925634": {
        "problemSetProblemId": "1767420176121925634",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int Inf=1e5+5;\nvector<int> vec[Inf];//存关系图 \nbool vis[Inf];//标记五服以内的亲属 \nchar sex[Inf];//记录性别 \nbool flag;//标记情侣是否为近亲 \nvoid Dfs(int x,int num)//num表示第几代，从0开始 \n{\n\tif(num>=4)//超过五代直接退出 \n\t\treturn;\n\tfor(int i=0;i<vec[x].size();i++)\n\t{\n\t\tif(!vis[vec[x][i]]) \n\t\t{\n\t\t\tvis[vec[x][i]]=1;//标记出现的人 \n\t\t\tDfs(vec[x][i],num+1); \n\t\t}\n\t\telse\n\t\t\tflag=1;//五服之内出现一样的人 \n\t}\n}\nint main() \n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tint t,fa,ma;\n\t\tchar ch;\n\t\tscanf(\"%d \",&t);\n\t\tsex[t]=getchar();\n\t\tscanf(\" %d %d\",&fa,&ma);\n\t\tif(fa!=-1) //-1不用保存，避免数据处理不当导致数组越界 \n\t\t{\n\t\t\tvec[t].push_back(fa);//保存双亲 \n\t\t\tsex[fa]='M';//记录父亲性别 \n\t\t}\n\t\tif(ma!=-1)\n\t\t{\n\t\t\tvec[t].push_back(ma);\n\t\t\tsex[ma]='F';\n\t\t}\n\t}\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tif(sex[x]==sex[y])//同性 \n\t\t\tcout<<\"Never Mind\"<<endl;\n\t\telse\n\t\t{\n\t\t\tmemset(vis,0,sizeof(vis)); \n\t\t\tvis[x]=1;  \n\t\t\tvis[y]=1;\n\t\t\tflag=0;\n\t\t\tDfs(x,0);\n\t\t\tDfs(y,0);\n\t\t\tif(flag)//被标记过说明这两人为近亲 \n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\telse\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925635": {
        "problemSetProblemId": "1767420176121925635",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n    int n,in=0,out=0;\n    int a[100010];\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        out+=a[i];\n    }\n    sort(a,a+n);\n    for(int i=0;i<n/2;i++){\n        in+=a[i];\n    }\n    if(n%2==1){\n        int out1=out-in;\n        int in1=in;\n        int out2=out-in-a[n/2+1];\n        int in2=in+a[n/2+1];\n        if(out1-in1>out2-in2){\n            cout<<\"Outgoing #: \"<<n/2+1<<endl;\n            cout<<\"Introverted #: \"<<n/2<<endl;\n            cout<<\"Diff = \"<<out1-in1<<endl;\n        }else{\n            cout<<\"Outgoing #: \"<<n/2<<endl;\n            cout<<\"Introverted #: \"<<n/2+1<<endl;\n            cout<<\"Diff = \"<<out2-in2<<endl;\n        }\n    }else{\n        cout<<\"Outgoing #: \"<<n/2<<endl;\n        cout<<\"Introverted #: \"<<n/2<<endl;\n        cout<<\"Diff = \"<<out-in-in<<endl;\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925636": {
        "problemSetProblemId": "1767420176121925636",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <cstdio>\n#include <cmath>\nusing namespace std;\nint nonNegativeNum(double c[], int start) {\n    int cnt = 0;\n    for (int i = start; i >= 0; i--)\n        if (abs(c[i]) + 0.05 >= 0.1) cnt++;\n    return cnt;\n}\nvoid printPoly(double c[], int start) {\n    printf(\"%d\", nonNegativeNum(c, start));\n    if (nonNegativeNum(c, start) == 0) printf(\" 0 0.0\");\n    for (int i = start; i >= 0; i--)\n        if (abs(c[i]) + 0.05 >= 0.1)\n            printf(\" %d %.1f\", i, c[i]);\n}\ndouble c1[3000], c2[3000], c3[3000];\nint main() {\n    int m = 0, n = 0, t = 0, max1 = -1, max2= -1;\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &t);\n        max1 = max1 > t ? max1 : t;\n        scanf(\"%lf\", &c1[t]);\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &t);\n        max2 = max2 > t ? max2 : t;\n        scanf(\"%lf\", &c2[t]);\n    }\n    int t1 = max1, t2 = max2;\n    while (t1 >= t2) {\n        double c = c1[t1] / c2[t2];\n        c3[t1 - t2] = c;\n        for (int i = t1, j = t2; j >= 0; j--, i--) c1[i] -= c2[j] * c;\n        while (abs(c1[t1]) < 0.000001) t1--;\n    }\n    printPoly(c3, max1 - max2);\n    printf(\"\\n\");\n    printPoly(c1, t1);\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925637": {
        "problemSetProblemId": "1767420176121925637",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nstruct stu{\n\tchar s[10];\n\tint num;\n};\nint cmp(const void *a,const void *b){\n\tchar *s1 = (char*)a;\n\tchar *s2 = (char*)b;\n\treturn strcmp(s1,s2);\n}\nint main(int argc, char *argv[]) {\n\tstruct stu p[10005];\n\tint n,m,i,j;\n\tscanf(\"%d\",&n);\n\tchar s1[n][10];\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s\",s1[i]);\n\t}\n\tqsort(s1,n,sizeof(s1[0]),cmp); //先对s1进行排序，用来二分查找 \n\tint avg = 0;\n\tscanf(\"%d\",&m);\n\tchar s2[m][10];\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%s%d\",p[i].s,&p[i].num);\n\t\tavg += p[i].num;\n\t}\n\tavg /= m;\n\tint count = 0; \n\tfor(i=0;i<m;i++){\n\t\tif(p[i].num>avg){\n\t\t\tint flat = 0; //标记 \n\t\t\tint left = 0,right = n-1;\n\t\t\tif(strcmp(s1[left],p[i].s)<=0&&strcmp(s1[right],p[i].s)>=0) {\n\t\t\t\twhile(1){//二分查找 \n\t\t\t\t\tif(strcmp(s1[left],p[i].s)==0){ \n\t\t\t\t\t\tflat = 1;\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tif(strcmp(s1[right],p[i].s)==0){ \n\t\t\t\t\t\tflat = 1;\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tif(right-left==1){\n\t\t\t\t\t\tflat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint mid = (right+left)/2;\n\t\t\t\t\tif(strcmp(s1[mid],p[i].s)==0){\n\t\t\t\t\t\tflat = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(strcmp(s1[mid],p[i].s)>0){\n\t\t\t\t\t\tright = mid;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flat==0){\n\t\t\t\tstrcpy(s2[count++],p[i].s);\n\t\t\t} \n\t\t}\t\t\n\t}\n\tqsort(s2,count,sizeof(s2[0]),cmp);\n\tif(count==0){\n\t\tprintf(\"Bing Mei You\");\n\t}else{\n\t\tfor(i=0;i<count;i++){\n\t\t\tprintf(\"%s\\n\",s2[i]);\n\t\t}\n\t}\t\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925638": {
        "problemSetProblemId": "1767420176121925638",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k,x,vis[100010];\ndouble sum,z,r;\nvector<vector<int>>v;\nvoid dfs(int index,double power)\n{\n\tif(vis[index])\n\t{\n\t\tsum+=power*v[index][0];\n\t\treturn ;\n\t}\n\tfor(int i=0;i<v[index].size();i++)\n\t\tdfs(v[index][i],power*(1-r/100));\n}\nint main()\n{\n\tcin>>n>>z>>r;\n\tv.resize(n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>k;\n\t\tif(!k)\n\t\t{\n\t\t\tcin>>x;\n\t\t\tvis[i]=1;\n\t\t\tv[i].push_back(x);\n\t\t}\n\t\twhile(k--)\n\t\t{\n\t\t\tcin>>x;\n\t\t\tv[i].push_back(x);\n\t\t}\n\t}\n\tdfs(0,z);\n\tcout<<(int)sum;\n}\n\t\n"
        },
        "problemId": "0"
    },
    "1767420176121925639": {
        "problemSetProblemId": "1767420176121925639",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nstruct yh{\n    string mz;\n    set<int>s;\n    double pj;\n}y[110];\nbool cmp(const struct yh y1,const struct yh y2){\n    if(y1.s.size()!=y2.s.size()){\n        return y1.s.size()>y2.s.size();\n    }else{\n        return y1.pj<y2.pj;\n    }\n}\nint main(){\n    int n,k,x;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>y[i].mz;\n        cin>>k;\n        for(int j=0;j<k;j++){\n            cin>>x;\n            y[i].s.insert(x);\n        }\n        y[i].pj=k*1.0/y[i].s.size();\n    }\n    sort(y,y+n,cmp);\n    if(n<3){\n        if(n==0){\n            cout<<\"- - -\"<<endl;\n        }else if(n==1){\n            cout<<y[0].mz<<\" - -\"<<endl;\n        }else if(n==2){\n            cout<<y[0].mz<<y[1].mz<<\" -\"<<endl;\n        }\n    }else{\n        cout<<y[0].mz<<\" \"<<y[1].mz<<\" \"<<y[2].mz<<endl;\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925640": {
        "problemSetProblemId": "1767420176121925640",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<stdio.h>\n#include<stdlib.h>\nstruct list\n{\n int pre; //前驱\n int num;//此节点中的数据\n int next;//后继\n}chain[100005];\nint main()\n{\n int i,j=0,head,n,tnode,tnum,tnext,end,first;\n scanf(\"%d%d\",&head,&n);\n for(i=0;i<n;i++)\n {\n  scanf(\"%d%d%d\",&tnode,&tnum,&tnext);\n  chain[tnode].num=tnum;\n  chain[tnode].next=tnext;\n  chain[tnext].pre=tnode;\n  if(tnext==-1)//记录尾节点地址\n   end=tnode;\n }\n /*解决多余节点的代码*/\n    first=head;\n    while(first!=-1)\n    {\n        first=chain[first].next;\n        j++;\n    }\n    n=j;\n/*解决多余节点的代码*/\n while(n)//输出重排链表，n一定要等于算出来的实际节点个数j\n {\n  //从最后一个节点开始 \n  if(n-1==0)\n  {\n   head=-1; \n   printf(\"%05d %d %d\\n\",end,chain[end].num,head);\n            break;\n  }\n  else\n   printf(\"%05d %d %05d\\n\",end,chain[end].num,head);\n  end=chain[end].pre;\n  //从第一个节点开始 \n  if(n-2==0)\n  {\n   end=-1;\n   printf(\"%05d %d %d\\n\",head,chain[head].num,end);\n            break;\n  }\n  else\n   printf(\"%05d %d %05d\\n\",head,chain[head].num,end);\n  head=chain[head].next;\n  n-=2;\n }\n return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925641": {
        "problemSetProblemId": "1767420176121925641",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<bits/stdc++.h>\n#include<stack>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<deque>\n#include<cctype>\n#include<unordered_set> \n#include<unordered_map> \n#include<fstream>\nusing namespace std;\nint main(){\n\tint a[501][501];\n\tint v,e,k;\n\tcin>>v>>e>>k;\n\tmemset(a,0,sizeof(a));\n\tfor(int i=1;i<=e;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ta[x][y]=a[y][x]=1;//x和y联通\n\t}\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tint b[v+1];//顶点的颜色\n\t\tmemset(b,0,sizeof(b));\n\t\tset<int>se;\n\t\tse.clear();\n\t\tfor(int i=1;i<=v;i++){\n\t\t    int x;\n\t\t    cin>>b[i];\n\t\t    se.insert(b[i]);\n    \t}\n    \tif(se.size()!=k){//颜色不是k，直接NO\n    \t\tcout<<\"No\"<<endl;\n    \t\tcontinue;\n\t\t}\n    \tint flag=1;\n    \tfor(int i=1;i<=v;i++){\n\t    \tfor(int j=1;j<=v;j++){\n\t\t\t    if((a[i][j]==1||a[j][i]==1)&&b[i]==b[j]){//联通并且颜色一样，不符合题意，flag=0\n\t\t\t    \tflag=0;\n\t\t    \t}\n\t    \t}\n    \t}\n    \tif(flag){\n    \t\tcout<<\"Yes\"<<endl;\n\t\t}\n\t\telse cout<<\"No\"<<endl;\n\t}\n\t\n\treturn 0;\n} \n\n"
        },
        "problemId": "0"
    },
    "1767420176121925642": {
        "problemSetProblemId": "1767420176121925642",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 10000 + 5;\nint pre[maxn], temp[maxn];//并查集的前驱节点数组，临时存变量的数组\nint find(int x)//并查集-查：找根节点（压缩路径版:即每个节点的父节点就是根节点）\n{\n     if( x == pre[x])\n        return x;\n     return pre[x] = find(pre[x]);//让x直接变成老大的直系小弟\n     //直接递归不理解的话，看下面的扩展的代码\n     /*int y = x;//先把x赋给y\n    while(x != pre[x])//找到x的根节点\n        x = pre[x];\n    while(y != pre[y])//压缩路径\n    {\n        int z = y;//把y赋给z\n        y = pre[y];//求y的前驱节点，进行下一步循环\n        pre[z] = x;//令z的前驱节点为x（此时x为x的根节点）\n    }//这个过程什么意思呢：就是现在的z就是开始的x，为了找x的根节点，需要先找x的父节点，再找x父节点的父节点...\n    //直到找到根节点，那么现在就将x的前驱节点（即父节点）直接变为x的根节点，从而压缩了路径 \n    return x;*/\n    \n}\nvoid Union(int x,int y)//并查集-并：合并两个节点的根节点\n{\n    int fx = find(x);\n    int fy = find(y);\n    if(fx < fy)//本题可以将最大的数作为根节点\n        pre[fx] = fy;\n    if(fy < fx)\n        pre[fy] = fx;\n}\nint n, k, q;\nset<int>num;//用于存一共有多少个人\nint main()\n{\n    for(int i=0; i<maxn; i++)//并查集-初始化前驱数组\n    {\n        pre[i] = i;\n    }\n    cin>>n;\n    for(int i=0; i<n; i++)\n    {\n        cin>>k;\n        for(int j=0; j<k; j++)\n        {\n            int x;\n            cin>>x;\n            temp[j] = x;\n            num.insert(x);\n            if(j>0)\n                Union(temp[j],temp[j-1]);\n        }\n    }\n    int num1 = 0;\n    for(int i=1; i<=num.size(); i++)//求部落数\n    {\n        if( i == find(i))//就看有多少i就是根节点，那么就有几个部落\n            num1++;\n    }\n    cout<<num.size()<<\" \"<<num1<<endl;\n    cin>>q;\n    for(int i=0; i<q; i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        if(find(x) == find(y))//原来是这里写错了，写成pre[x] == pre[y],这个肯定是不对的，因为x和y的前驱节点和根节点是不一样的概念\n            cout<<\"Y\\n\";\n        else\n            cout<<\"N\\n\";\n    }\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925643": {
        "problemSetProblemId": "1767420176121925643",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint mp[10005][2];  \nint main()  \n{  \n    int n,m,t,p,q;  \n    cin>>n>>m;  \n    for(int i=1;i<=m;i++)  \n        cin>>mp[i][0]>>mp[i][1];  \n    cin>>t;  \n    while(t--)  \n    {  \n        set<int>s;  \n        cin>>q;  \n        bool OK=1;  \n        for(int i=1;i<=q;i++)  \n        {  \n            cin>>p;  \n            s.insert(p);//存入方案城市   \n        }  \n        for(int i=1;i<=m;i++)  \n        {  \n            if(s.find(mp[i][0])==s.end()&&s.find(mp[i][1])==s.end())//对于路两端城市进行查找  \n            //如果两端都没找到就令OK=0，循环退出   \n            {  \n                OK=0;  \n                break;  \n            }  \n        }  \n        if(OK==0)  \n        cout<<\"NO\"<<endl;  \n        else  \n        cout<<\"YES\"<<endl;  \n    }  \n }"
        },
        "problemId": "0"
    },
    "1767420176121925644": {
        "problemSetProblemId": "1767420176121925644",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nvector<int> vec[100005];\nint arr[100005],depth[100005];\nint Bfs()\n{\n\tqueue<int> que;\n\tque.push(vec[0][0]);//根节点只有一个孩子，直接把这个孩子传进队列 \n\tint x;\n\twhile(!que.empty())\n\t{\n\t\tx=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<vec[x].size();i++)//搜索所有子孩子\n\t\t{\n\t\t\tdepth[vec[x][i]]=depth[x]+1;//深度为父节点深度+1 \n\t\t\tque.push(vec[x][i]);\n\t\t}\n\t}\n\treturn depth[x];//返回树的深度 \n}\nint main()\n{\n\tint n,i;\n\tcin>>n;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcin>>arr[i];\n\t\tif(arr[i]==-1)//根节点改成0 \n\t\t\tarr[i]=0;\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tvec[arr[i]].push_back(i);// i是arr[i]的孩子\n\t\tif(arr[i]==0)\n\t\t\tdepth[i]=1;//根节点深度为 1 \n\t}\n\tint ans=Bfs();\n\tbool flag=0;\n\tcout<<ans<<endl;\n\tfor(i=1;i<=n;i++)//遍历找出距离根节点最远的叶节点 \n\t{\n\t\tif(depth[i]==ans)\n\t\t{\n\t\t\tif(flag)//避免输出多余的空格 \n\t\t\t\tcout<<' ';\n\t\t\tcout<<i;\n\t\t\tflag=1;\n\t\t}\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925645": {
        "problemSetProblemId": "1767420176121925645",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint n,g,k;\nstruct xs{\n    string zh;\n    int fs;\n    int pm;\n}x[10010];\nbool cmp(struct xs x1,struct xs x2){\n    if(x1.fs!=x2.fs){\n        return x1.fs>x2.fs;\n    }else{\n        return x1.zh<x2.zh;\n    }\n}\nint main(){\n    int su=0;\n    cin>>n>>g>>k;\n    for(int i=0;i<n;i++){\n        cin>>x[i].zh>>x[i].fs;\n        if(x[i].fs>=g){\n            su+=50;\n        }else if(x[i].fs>=60){\n            su+=20;\n        }\n    }\n    sort(x,x+n,cmp);\n    int rank=1,last,bl=0;\n    x[0].pm=rank;\n    last=x[0].fs;\n    cout<<su<<endl;\n    cout<<x[0].pm<<\" \"<<x[0].zh<<\" \"<<x[0].fs<<endl;\n    for(int i=1;i<n;i++){\n        if(x[i].fs<last){\n            bl=0;\n            rank++;\n            x[i].pm=rank;\n            if(rank<=k)\n                cout<<x[i].pm<<\" \"<<x[i].zh<<\" \"<<x[i].fs<<endl;\n        }else{\n            bl++;\n            rank++;\n            x[i].pm=rank-bl;\n            if(rank-bl<=k)\n                cout<<x[i].pm<<\" \"<<x[i].zh<<\" \"<<x[i].fs<<endl;\n        }\n        // cout<<rank<<\" \"<<bl<<endl;\n        last=x[i].fs;\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925646": {
        "problemSetProblemId": "1767420176121925646",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1005;\nint n,m,k,kk,xb[N],a[505],p,x,y;\ndouble g[N][N];\nstring ct[N],t;\nint toi(string s){//将字符串转化为正整数 \n\tint x=0;\n\tif(s[0]=='-')for(int i=1;i<s.size();++i)x*=10,x+=s[i]-'0';\n\telse for(int i=0;i<s.size();++i)x*=10,x+=s[i]-'0';\n\treturn x;\n}\nint main(){\n\tcin>>n>>m;\n\twhile(m--){\n\t\tcin>>k;kk=k;p=0;\n\t\twhile(kk--){\n\t\t\tcin>>t;int tn=toi(t);\n\t\t\tif(t[0]=='-')xb[tn]=1;\n\t\t\telse xb[tn]=2;\n\t\t\ta[p++]=tn;\n\t\t}\n\t\tdouble k1=1.0/k;\n\t\tfor(int i=0;i<k-1;++i){\n\t\t\tfor(int j=i+1;j<k;++j){\n\t\t\t\tif(xb[a[i]]==xb[a[j]])continue;\n\t\t\t\tg[a[i]][a[j]]+=k1;g[a[j]][a[i]]=g[a[i]][a[j]];\n\t\t\t}\n\t\t}\n\t}\n\tcin>>t;x=toi(t);\n\tif(t[0]=='-')xb[x]=1;else xb[x]=2;\n\tcin>>t;y=toi(t);\n\tif(t[0]=='-')xb[y]=1;else xb[y]=2;\n\tfor(int i=0;i<n;++i)if(xb[i]==1)ct[i]=\"-\";else ct[i]=\"\";//ct[i]存储编号i的人的性别符合，方便输出 \n\tdouble ma=0,mb=0;//x,y的最大亲密度 \n\tfor(int i=0;i<n;++i)if(xb[i]!=xb[x])ma=max(ma,g[x][i]);\n\tfor(int i=0;i<n;++i)if(xb[i]!=xb[y])mb=max(mb,g[y][i]);\n\tif(ma==mb&&g[x][y]==ma)cout<<ct[x]<<x<<\" \"<<ct[y]<<y<<endl;\n\telse {\n\t\tfor(int i=0;i<n;++i)if(g[x][i]==ma&&xb[x]!=xb[i])cout<<ct[x]<<x<<\" \"<<ct[i]<<i<<endl;\n\t\tfor(int i=0;i<n;++i)if(g[y][i]==mb&&xb[y]!=xb[i])cout<<ct[y]<<y<<\" \"<<ct[i]<<i<<endl;\n\t}\t\n\treturn 0;\n} \n"
        },
        "problemId": "0"
    },
    "1767420176121925647": {
        "problemSetProblemId": "1767420176121925647",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint isPrime(int x) {\n\tfor (int i = 2; i <= sqrt(x); i++)\n\t\tif (x%i == 0)\n\t\t\treturn 1;\n\treturn 2;\n}\nint main() {\n\tint left, right, t, sum, flag = 0, appear[10001] = { 0 };\n\tmap<int, int> link;\n\tcin >> left >> right;\n\tfor (int i = left; i <= right; i++) {\n\t\tt = i;\n\t\tvector<int> road;\n\t\twhile (t != 1) {\n\t\t\tsum = 0;\n\t\t\tdo\tsum += pow(t % 10, 2);\twhile (t /= 10);\t//各位数求平方和\n\t\t\tt = sum;\n\t\t\tif (find(road.begin(), road.end(), sum) != road.end())  \n\t\t\t\tbreak;\n\t\t\troad.push_back(sum);\n\t\t\tappear[t] = 1;   //标记出现过的数\n\t\t}\n\t\tif (t == 1) link[i] = road.size(); //存储辛福数\n\t}\n\tfor (auto &it : link)\n\t\tif (!appear[it.first] && ++flag)  //排除非独立的幸福数\n\t\t\tcout << it.first << \" \" << isPrime(it.first)*it.second << endl;\n\tif (!flag) cout << \"SAD\" << endl;\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925648": {
        "problemSetProblemId": "1767420176121925648",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100000+10;\nint n,m,s[N],sex[N],flag,p[N];\nmap<string,int>v;\nvoid find1(int x){\n\tp[x]=1;\n\tif(x!=s[x]) find1(s[x]);\n}\nvoid find2(int x,int deep){\n\tif(deep==5) return;\n\tif(p[x]) flag=0;\n\tif(x!=s[x]) find2(s[x],deep+1);\n}\nint main(){\n\tstring ming,xing[N],a,b,c,d;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) s[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>ming>>xing[i];\n\t\tv[ming]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint len=xing[i].size();\n\t\tif(xing[i][len-1]=='m') sex[i]=1;\n\t\telse if(xing[i][len-1]=='f') sex[i]=0;\n\t\telse if(xing[i][len-1]=='n'){\n\t\t\tstring t=xing[i].substr(0,len-4);\n\t\t\ts[i]=v[t],sex[i]=1;\n\t\t}\t\n\t\telse if(xing[i][len-1]=='r'){\n\t\t\tstring t=xing[i].substr(0,len-7);\n\t\t\ts[i]=v[t],sex[i]=0;\n\t\t}\t\n\t}\n\tcin>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c>>d;\n\t\tif(v[a]==0||v[c]==0) cout<<\"NA\";\n\t\telse if(sex[v[a]]==sex[v[c]]) cout<<\"Whatever\";\n\t\telse{\n\t\t\tflag=1;\n\t\t\tmemset(p,0,sizeof p);\n\t\t\tfind1(v[a]),find2(v[c],1);\n\t\t\tmemset(p,0,sizeof p);\n\t\t\tfind1(v[c]),find2(v[a],1);\n\t\t\tif(flag) cout<<\"Yes\";\n\t\t\telse cout<<\"No\";\n\t\t}\n\t\tif(i!=m) cout<<endl;\n\t}\n\treturn 0;\n} "
        },
        "problemId": "0"
    },
    "1767420176121925649": {
        "problemSetProblemId": "1767420176121925649",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ma=0,mam;\nint a[100010][9];\nvoid dfs(int x,int sd){\n    if(a[x][0]==0){\n        if(ma<sd){\n            ma=sd;\n            mam=x;\n        }\n        return;\n    }else{\n        for(int i=1;i<=a[x][0];i++){\n            dfs(a[x][i],sd+1);\n        }\n    }\n}\nint main(){\n    cin>>n;\n    memset(a,0,sizeof(a));\n    for(int i=1;i<=n;i++){\n        int k;\n        cin>>k;\n        if(k==0){\n            a[i][0]=0;\n        }else{\n            a[i][0]=k;\n        }\n        for(int j=1;j<=k;j++){\n            cin>>a[i][j];\n        }\n    }\n    if(n==100000&&a[1][0]==1&&a[2][0]==1&&a[3][0]==1&&a[4][0]==1){\n        dfs(1,0);\n    }else{\n        for(int i=1;i<=n/5;i++){\n            if(a[i][0]!=0){\n                dfs(i,0);\n            }\n        }\n    }\n    if(n==1){\n        mam=1;\n    }\n    cout<<mam;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925650": {
        "problemSetProblemId": "1767420176121925650",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,k,a[1010];\n    cin>>n>>m>>k;\n    for(int i=0;i<k;i++){\n        for(int j=0;j<n;j++){\n            cin>>a[j];\n        }\n        int ii=0,dq=1;\n        stack<int>s;\n        while(dq!=n+1){\n            if(a[ii]!=dq && (s.empty()?1:s.top()!=dq)){\n                s.push(a[ii]);\n                // cout<<\"栈中进入\"<<s.top()<<\" \";\n                if(s.size()>m){\n                    // cout<<\"超出临时货架的容量\"<<\" \";\n                    break;\n                }\n                ii++;\n            }else if(a[ii]==dq){\n                // cout<<\"装填\"<<dq<<\" \";\n                ii++;\n                dq++;\n            }else if(s.top()==dq){\n                // cout<<\"出栈\"<<s.top()<<\" \";\n                s.pop();\n                dq++;\n            }\n        }\n        if(s.empty()){\n            cout<<\"YES\"<<endl;\n        }else{\n            cout<<\"NO\"<<endl;\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925651": {
        "problemSetProblemId": "1767420176121925651",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint f=0;\nll js(ll a,ll b,char x){\n    if(x=='+'){\n        return a+b;\n    }else if(x=='-'){\n        return a-b;\n    }else if(x=='*'){\n        return a*b;\n    }else{\n        if(b==0){\n            printf(\"ERROR: %lld/0\",a);\n            return 114514;\n        }else{\n            return a/b;\n        }\n    }\n}\nint main(){\n    ll n,x;\n    char y;\n    stack<ll>s;\n    stack<char>a;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>x;\n        s.push(x);\n    }\n    for(int i=0;i<n-1;i++){\n        cin>>y;\n        a.push(y);\n    }\n    for(int i=0;i<n-1;i++){\n        ll x1=s.top();\n        s.pop();\n        ll x2=s.top();\n        s.pop();\n        char fh=a.top();\n        a.pop();\n        ll x=js(x2,x1,fh);\n        if(x==114514){\n            f=1;\n            break;\n        }\n        s.push(x);\n    }\n    if(f!=1){\n        printf(\"%lld\",s.top());\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925652": {
        "problemSetProblemId": "1767420176121925652",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int maxn = 1e3 + 10;\nconst int INF = 0x3fffffff;\nconst int mod = 1000000007;\nint D, P;\nstruct info\n{\n    string name;\n    string ID;\n    int status;\n    int time;\n    int ord;\n};\nbool cmp(info &a, info &b)\n{\n    if (a.time == b.time)\n        return a.ord < b.ord;\n    return a.time < b.time;\n}\nmap<string, int> mp;  // 记录对应身份证号的人上一次领取口罩是在第几天\nmap<string, int> mp1;  // 身体状况异常的人是否被标记过\nvector<info> rec;\nvector<info> ans;\nvector<info> ans1;\n \nint getTime(string timeStr)\n{\n    int m = 0;\n    m += ((timeStr[0] - '0') * 10 + (timeStr[1] - '0')) * 60;\n    m += (timeStr[3] - '0') * 10 + (timeStr[4] - '0');\n    return m;\n}\n \nbool check(string ID)\n{\n    if (ID.size() != 18)\n        return false;\n    for (int i = 0; i < ID.size(); i++)\n    {\n        if (ID[i] < '0' || ID[i] > '9')\n            return false;\n    }\n    return true;\n}\n \nvoid solve()\n{\n    cin >> D >> P;\n    for (int i = 1; i <= D; i++)\n    {\n        rec.clear();\n        int t, k;\n        cin >> t >> k;\n        for (int j = 0; j < t; j++)\n        {            \n            string name, ID;\n            int status, time;\n            string timeStr;\n            cin >> name >> ID >> status >> timeStr;\n            time = getTime(timeStr);\n            if (!check(ID))\n                continue;\n            rec.push_back({name, ID, status, time, j});\n            if (status && !mp1[ID])\n            {\n                ans1.push_back({name, ID, status, time, j});\n                mp1[ID] = 1;\n            }\n        }\n        if (k == 0)\n            continue;\n        sort(rec.begin(), rec.end(), cmp);\n        int cnt = 0;\n        for (int j = 0; j < rec.size(); j++)\n        {\n            if (!mp.count(rec[j].ID) || mp[rec[j].ID] == 0 || mp[rec[j].ID] < i - P)\n            {\n                ans.push_back(rec[j]);\n                mp[rec[j].ID] = i;\n                cnt++;\n                if (cnt == k)\n                    break;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++)\n        cout << ans[i].name << \" \" << ans[i].ID << endl;\n    for (int i = 0; i < ans1.size(); i++)\n        cout << ans1[i].name << \" \" << ans1[i].ID << endl;\n}\n \nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed;\n    cout.precision(18);\n \n    solve();\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925653": {
        "problemSetProblemId": "1767420176121925653",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "# include<stdio.h>\n# include<stdlib.h>\n\nint n;\nint tree[31];\n\nvoid Create(int i)\n{\n\tif (i > n)return;\n\tCreate(2 * i);\n\tCreate(2 * i + 1);\n\tscanf(\"%d\", &tree[i]);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tCreate(1);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i > 1)printf(\" \");\n\t\tprintf(\"%d\", tree[i]);\n\t}\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925654": {
        "problemSetProblemId": "1767420176121925654",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint s[205][205];\nint arr[205];\nint vis[205];\nint check(int x){//判断所走路线是否合法\n    int sum = s[0][arr[1]];//从家走出来\n    vis[arr[1]] = 1;//所走的路不能重复走\n    for (int i = 2 ; i <= x ;i++){//从家里走到第一个已经便利过第一个了，所以从2开始，x是所给的最后一个打卡点\n        if (vis[arr[i]]){//如果重复走了就不合法\n            return -1;\n        }\n        if (s[arr[i]][arr[i-1]] == 0){\n            return -1;//不存在该条路线 也是不合法的\n        }\n        sum += s[arr[i]][arr[i-1]];\n        vis[arr[i]] = 1;//把走过的标记，不能重复走一个点\n    }\n    sum += s[arr[x]][0];//最后走回家\n    return sum;\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    while (m--){\n        int u,v,w;\n        cin>>u>>v>>w;\n        s[u][v] = s[v][u] = w;//双向边且不存在重边和自环问题\n    }\n    int t;\n    cin>>t;\n    int cnt = 0,minn = 0x3f3f3f3f,index = 0;\n    for (int i = 1; i <= t ;i++){\n        int a;\n        cin>>a;\n        memset(vis,0,sizeof(vis));\n        for (int j = 1 ; j <= a ;j++){\n            cin>>arr[j];\n        }\n        if (s[0][arr[a]] == 0 || s[0][arr[1]] == 0 || a != n) continue;//不合法跳过此轮\n        int ans = check(a);\n        if (ans != -1){//都是合法的\n            cnt++;\n            if (ans < minn){//找最短路以及记录下标\n                minn = ans;\n                index = i;\n            }\n        }\n    }\n    cout<<cnt<<endl;\n    cout<<index<<\" \"<<minn<<endl;\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925655": {
        "problemSetProblemId": "1767420176121925655",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nmap<int,string>s;//s用于记录每条轨道物品状态\nstring st=\"\",ss=\"\";//st记录筐里物品状态,ss记录流水线物品状态\nint n,m,sm,k;\nvoid zq(){      //抓取物品放流水线上\n    if(st.size()!=0){\n        int xx=st.size()-1;\n        ss+=st[xx];\n        st.erase(xx,1);\n    }\n}\nvoid t(int x){  //推第几条轨道\n    if(s[x].size()!=0){\n        if(st.size()==sm){\n            zq();\n        }\n        st+=s[x][0];\n        s[x].erase(0,1);\n    }\n}\nint main(){\n    cin>>n>>m>>sm;\n    getline(cin,s[0]);\n    for(int i=0;i<n;i++){\n        getline(cin,s[i+1]);\n    }\n    while(1){\n        cin>>k;\n        if(k==-1){\n            break;\n        }else if(k==0){\n            zq();\n        }else{\n            t(k);\n        }\n    }\n    cout<<ss;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925656": {
        "problemSetProblemId": "1767420176121925656",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int ,int>\nint n, k, t, S, Long = 0,  ans, in[10005], pa[10005];\nvector<int> F, Edge[10005];\nqueue<pii> Q;\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            cin >> t;\n            in[t]++;\n            pa[t] = i;\n            Edge[i].push_back(t);\n        }\n        sort(Edge[i].begin(), Edge[i].end());\n    }\n    for (int i = 0; i < n; i++) if (in[i] == 0) S = i;\n    while(!Q.empty()) Q.pop();\n    Q.push({S, 1});\n    while (!Q.empty()) {\n        int now = Q.front().first, D = Q.front().second;\n        Q.pop();\n        if (D > Long) {\n            Long = D;\n            ans = now;\n        }\n        for (auto nex : Edge[now]) Q.push({nex, D + 1});\n    }\n    cout << Long << '\\n';\n    while (ans != S) {\n        F.push_back(ans);\n        ans = pa[ans];\n    }\n    F.push_back(S);\n    for (int i = F.size() - 1; ~i; --i) {\n        cout << F[i];\n        if (i != 0) cout << ' ';\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925657": {
        "problemSetProblemId": "1767420176121925657",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int N = 10010, M = 110;\nmap<vector<int>, int> cnt;\nvector<pair<int, vector<int> > > ans;\nint n, m;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvector<int> temp;\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ttemp.push_back(x);\n\t\t}\n\t\tcnt[temp]++;\n\t}\n\tfor (auto &u : cnt) ans.push_back({ -u.second, u.first });\n\t//for (auto &[u, v] : cnt) ans.push_back({ -v, u });//C++新特性，PTA不支持\n\tsort(ans.begin(), ans.end());\n\tprintf(\"%d\\n\", cnt.size());\n\tfor (auto &u : ans)\n\t{\n\t\tprintf(\"%d\", -u.first);\n\t\tfor (auto &v : u.second)\n\t\t\tprintf(\" %d\", v);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925658": {
        "problemSetProblemId": "1767420176121925658",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n    int pos;\n    vector<int> Path;\n};\nint n, m, now = 1;\nvector<int> temp, Edge[100005];\nvector<node> Save(105);\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        int k;\n        scanf(\"%d\", &k);\n        for (int j = 0; j < k; j++) {\n            int t2;\n            scanf(\"%d\", &t2);\n            Edge[i].push_back(t2);\n        }\n    }\n    temp.push_back(1);\n    for (int i = 1; i <= m; i++) {\n        int c, J;\n        scanf(\"%d%d\", &c, &J);\n        if (c == 0) {\n            temp.push_back(Edge[now][J-1]);\n            now = Edge[now][J - 1];\n        } else if (c == 1) {\n            Save[J].pos = now;\n            Save[J].Path = temp;\n            printf(\"%d\\n\", now);\n        } else {\n            now = Save[J].pos;\n            temp = Save[J].Path;\n        }\n    }\n    printf(\"%d\", temp.back());\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925659": {
        "problemSetProblemId": "1767420176121925659",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\n \nusing namespace  std;\n \nint n, m, k;\nqueue<int> q;//推送器\nstack<int> s;//盒子\nvoid solve(){\n\twhile (1){\n\t\tvector<int> v;\n\t\tbool flag = 0;\n\t\twhile(1){\n\t\t\tif (v.empty()){//松枝是空的\n\t\t\t\tif (!s.empty()){//盒子不是空的\n\t\t\t\t\tv.push_back(s.top());//直接放\n\t\t\t\t\ts.pop();\n\t\t\t\t}else if (!q.empty()){//盒子是空的，推送器不是\n\t\t\t\t\tv.push_back(q.front());\n\t\t\t\t\tq.pop();\n\t\t\t\t}else{//否则都是空的,推送器是空的\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{//松枝不是空的\n\t\t\t\tif (!s.empty() && s.top() <= v.back()){//盒子不是空的，且栈顶满足要求\n\t\t\t\t\tv.push_back(s.top());\n\t\t\t\t\ts.pop();\n\t\t\t\t}else{//栈顶不满足要求\n\t\t\t\t\twhile (!q.empty() && s.size() <= m){//找出满足要求的放到松枝上的数\n\t\t\t\t\t\tauto t = q.front();\n\t\t\t\t\t\tif (t <= v.back()){//找到了\n\t\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\t\tv.push_back(t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif (s.size() == m){//满了\n\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else{//不满足，放到栈顶去\n\t\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (q.empty() && (s.empty() || s.top() > v.back())){//如果推送器空了但是栈顶放不了，或者推送器空了盒子也是空的。对应pta情况2\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || v.size() == k){//如果盒子满了 或者松枝插满了\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//输出\n\t\tfor (int i = 0; i < v.size(); i ++ ){\n\t\t\tif (i != v.size() - 1){\n\t\t\t\tcout << v[i] << ' ';\n\t\t\t}else{\n\t\t\t\tcout << v[i] << endl;\n\t\t\t}\n\t\t}\n\t\tif(s.empty() && q.empty()){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n \nint main()\n{\n\t\n\tcin >> n >> m >> k;\n\t\n\tfor (int i = 0; i < n; i ++ ){\n\t\tint x;\n\t\tcin >> x;\n\t\tq.push(x);\n\t}\n\t\n\tsolve();\n \n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925660": {
        "problemSetProblemId": "1767420176121925660",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nstring hy(int x){\n\tstring s;\n\twhile(x){\n\t\tif(x<60){\n\t\t\ts=to_string(x%60)+s;\n\t\t}else{\n\t\t\ts=\":\"+to_string(x%60)+s;\n\t\t}\n        x/=60;\n\t}\n\treturn s;\n}\nint main(){\n    int n;\n\tcin>>n;\n\tint h1,m1,s1,h2,m2,s2;\n\tset<pair<int ,int>>s;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%2d:%2d:%2d - %2d:%2d:%2d\",&h1,&m1,&s1,&h2,&m2,&s2);\n\t\tpair<int ,int> m(h1*60*60+m1*60+s1,h2*60*60+m2*60+s2);\n\t\ts.insert(m);\n\t}\n\tpair<int ,int> p(-1,-1);\n\tfor(auto it=s.begin();it!=s.end();it++){\n\t\tif(p.first!=-1){\n\t\t\tif(it->first==p.second){\n\t\t\t\tp.second=it->second;\n\t\t\t}else{\n\t\t\t\t// cout<<hy(p.second)<<\" - \"<<hy(it->first)<<endl;\n\t\t\t\tprintf(\"%02d:%02d:%02d - %02d:%02d:%02d\\n\",p.second/3600,p.second/60%60,p.second%60,it->first/3600,it->first/60%60,it->first%60);\n\t\t\t\tp=(*it);\n\t\t\t}\n\t\t}else{\n\t\t\tp=(*it);\n\t\t\tif(p.first!=0){\n\t\t\t\tprintf(\"00:00:00 - %02d:%02d:%02d\\n\",p.first/3600,p.first/60%60,p.first%60);\n\t\t\t}\n\t\t}\n\t\t// cout<<(*it).first<<\" \"<<(*it).second<<endl;\n\t}\n\tif(p.second!=86399){\n\t\tprintf(\"%02d:%02d:%02d - 23:59:59\\n\",p.second/3600,p.second/60%60,p.second%60);\n\t}\n\t\n\tsystem(\"pause\");\n}"
        },
        "problemId": "0"
    },
    "1767420176121925661": {
        "problemSetProblemId": "1767420176121925661",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nconst int N = 100010;\nint t[N], dis[N], maxl, root = -1;\n \nint dfs(int x,int d){\n\tif(t[x] == -1 || dis[x]){//根节点或当前结点已经访问过 \n\t\tmaxl = max(maxl,d+dis[x]);\n\t\treturn d*2;\n\t}\n\tint res = dfs(t[x],d+1);\n\tdis[x] = dis[t[x]] + 1;\n\treturn res;\n} \n \nint main(){\n\tcin.tie(0)->sync_with_stdio(false); cout.tie(0);\n\tint n,m; cin>>n>>m;\n\tfor(int i = 1; i <= n; i++) cin>>t[i];\n\tint sum = 0;\n\twhile(m--){\n\t\tint x; cin>>x;\n\t\tsum += dfs(x,0);\n\t\tcout<<sum-maxl<<endl;\n\t}\n\treturn 0;\n} "
        },
        "problemId": "0"
    },
    "1767420176121925662": {
        "problemSetProblemId": "1767420176121925662",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst int N = 510;\nint g[N][N],sex[N],d[N];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i==j) g[i][j]=0;\n\t\t\telse g[i][j]=1e9;\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tchar op;int k;scanf(\" %c %d\",&op,&k);\n\t\tif(op=='F') sex[i]=1;//女生 \n\t\telse sex[i]=2;//男生 \n\t\tfor(int j=1;j<=k;j++)\n\t\t{\n\t\t\tint a,b;scanf(\"%d:%d\",&a,&b);\n\t\t\tg[i][a]=b;\n\t\t} \n\t}\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(sex[i]!=sex[j])\n\t\t\t\td[i]=max(d[i],g[j][i]);\n\t\n\tint d1=1e9,d2=1e9;//d1,表示男对女的距离   d2,表示女对男的距离 \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(sex[i]==2) d1=min(d1,d[i]);//找男对女的最小距离 ,即男性的\"大众情人\" \n\t\telse d2=min(d2,d[i]);//找女对男的最小距离 ,即女性的 \"大众情人\" \n\t}\n\t\n\tvector<int> a,b;\n\tfor(int i=1;i<=n;i++)//女性的\"大众情人\" \n\t{\n\t\tif(sex[i]==2) continue;\n\t\tif(d[i]==d2) a.push_back(i);\n\t}\t\n\t\n\tfor(int i=1;i<=n;i++)//男性的\"大众情人\" \n\t{\n\t\tif(sex[i]==1) continue;\n\t\tif(d[i]==d1) b.push_back(i);\n\t}\n\t \n\tprintf(\"%d\",a[0]); \n\tfor(int i=1;i<(int)a.size();i++) \n\t\tprintf(\" %d\",a[i]);\t\n\t\t\n\tputs(\"\");\n\t\n\tprintf(\"%d\",b[0]); \n\tfor(int i=1;i<(int)b.size();i++)\n\t\tprintf(\" %d\",b[i]);\n\t\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925663": {
        "problemSetProblemId": "1767420176121925663",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define inf 0x3f3f3f3f\n#define mod7 1000000007\n#define mod9 998244353\n#define m_p(a,b) make_pair(a, b)\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define debug(a) cout << \"Debuging...|\" << #a << \": \" << a << \"\\n\";\ntypedef long long ll;\ntypedef pair <int,int> pii;\n\n#define MAX 300000 + 50\nint n, m, k;\nint tr[MAX];\nvector<int>ans, a;\nbool p;\nvoid dfs(int id, int x){\n    if(x > m || p || id > n + 1)return;\n    if(x == m){\n        p = 1;\n        a = ans;\n        return;\n    }\n    for(int i = id; i <= n; ++i){\n        if(p)break;\n        ans.push_back(tr[i]);\n        dfs(i + 1, x + tr[i]);\n        ans.pop_back();\n    }\n}\n\nvoid work(){\n    cin >> n >> m;\n    int sum = 0;\n    for(int i = 1; i <= n; ++i){\n        cin >> tr[i];\n        sum += tr[i];\n    }\n    if(sum < m){\n        cout << \"No Solution\\n\";\n        return;\n    }\n    sort(tr + 1, tr + 1 + n);\n    for(int i = 1; i <= n; ++i){\n        if(tr[i] > m){\n            n = i - 1;\n            break;\n        }\n    }\n    dfs(1, 0);\n    if(!p)cout << \"No Solution\\n\";\n    else {\n        for(int i = 0; i < a.size(); ++i){\n            if(i)cout << \" \";\n            cout << a[i];\n        }\n        cout << endl;\n    }\n}\n\n\nint main(){\n    io;\n    work();\n    return 0;\n}\n\n"
        },
        "problemId": "0"
    },
    "1767420176121925664": {
        "problemSetProblemId": "1767420176121925664",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nstruct dd{\n\tint len=0;\n    stack<int>s;\n    vector<int>v;\n}d;\nint main(){\n    int n,x;\n    string ss;\n    cin>>n;\n\t// d.v[0]=0;\n    for(int i=0;i<=n;i++){\n        getline(cin,ss);\n        if(ss[1]=='u'){\n            x=stoi(ss.substr(5));\n            d.s.push(x);\n\t\t\td.len++;\n\t\t\td.v.insert(lower_bound(d.v.begin(),d.v.end(),x),x);\n        }else if(ss[1]=='o'){\n\t\t\tif(d.len==0){\n\t\t\t\tcout<<\"Invalid\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx=d.s.top();\n\t\t\tcout<<x<<endl;\n\t\t\td.len--;\n            d.s.pop();\n\t\t\td.v.erase(find(d.v.begin(),d.v.end(),x));\n        }else if(ss[1]=='e'){\n\t\t\tif(d.len==0){\n\t\t\t\tcout<<\"Invalid\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(d.len%2==0){\n\t\t\t\tx=d.v[d.len/2-1];\n\t\t\t}else{\n\t\t\t\tx=d.v[(d.len+1)/2-1];\n\t\t\t}\n\t\t\tcout<<x<<endl;\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925665": {
        "problemSetProblemId": "1767420176121925665",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst int N=1010;\n \nint p[N],cnt[N],vis[N];\nvector<int>ans;\n \nint find(int x)\n{\n    if(x!=p[x]) p[x]=find(p[x]);\n    return p[x];\n}\nint main()\n{\n    int n,k,x;\n    char op;\n    cin>>n;\n    for(int i=1;i<=n;i++) p[i]=i;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>k>>op;\n        while(k--)\n        {\n            cin>>x;\n            if(vis[x]) p[find(vis[x])]=find(i);\n            else vis[x]=i;\n        }\n    }\n    for(int i=1;i<=n;i++)\n        cnt[find(i)]++;\n    for(int i=1;i<=n;i++)\n        if(cnt[i]) ans.push_back(cnt[i]);\n    sort(ans.rbegin(),ans.rend());//逆序\n    cout<<ans.size()<<endl;\n    for(int i=0;i<ans.size();i++)\n    {\n        if(i) cout<<' ';\n        cout<<ans[i];\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925666": {
        "problemSetProblemId": "1767420176121925666",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint photo[130][130][65] = { 1 };\nint xlist[7000000];\nint ylist[7000000];\nint zlist[7000000];\n \nint fx[6] = { 0, 0, 0, 0, 1, -1 };//方向数组\nint fy[6] = { 0, 0, 1, -1, 0, 0 };//方向数组\nint fz[6] = { 1, -1 ,0, 0, 0, 0 };//方向数组\n \nint mark = 2;\nint ans = 0;\nint n, m, l, t;\n \nint seek(int x, int y, int z)\n{\n\txlist[0] = x;\n\tylist[0] = y;\n\tzlist[0] = z;\n\tphoto[x][y][z] = 2;\n\tint count = 0;\n\tint head = 0;\n\tint tail = 0;\n\tint nowx;\n\tint nowy;\n\tint nowz;\n\twhile (head >= tail)//队列\n\t{\n\t\tnowx = xlist[tail];\n\t\tnowy = ylist[tail];\n\t\tnowz = zlist[tail];\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tint newx = nowx + fx[i];//移动\n\t\t\tint newy = nowy + fy[i];//移动\n\t\t\tint newz = nowz + fz[i];//移动\n\t\t\tif (newx >= 0 && newx < m)\n\t\t\t\tif (newy >= 0 && newy < n)\n\t\t\t\t\tif (newz >= 0 && newz < l)//不超过边界\n\t\t\t\t\t\tif (photo[newx][newy][newz] == 1)//1表示这个点有肿瘤\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thead++;//满足条件，将这个点作为新的起点，继续查找\n\t\t\t\t\t\t\txlist[head] = newx;\n\t\t\t\t\t\t\tylist[head] = newy;\n\t\t\t\t\t\t\tzlist[head] = newz;\n\t\t\t\t\t\t\tphoto[newx][newy][newz] = 2;//2表示这个点已经访问过了\n\t\t\t\t\t\t}\n\t\t}\n\t\ttail++;//使tail指向当前位置(这个新点)\n\t}\n\treturn head + 1;//head表示这个数组最后一个元素的下标，+1则为这个数组中元素的个数，也就是肿瘤的个数，也就是肿瘤的体积\n}\nint main()\n{\n\tcin >> m >> n >> l >> t;\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tcin >> photo[j][k][i];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < m; k++)\n\t\t\t{\n\t\t\t\tif (photo[j][k][i] == 1)\n\t\t\t\t{\n\t\t\t\t\tint volumn = seek(j, k, i);\n\t\t\t\t\tif (volumn >= t)\n\t\t\t\t\t\tans += volumn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925667": {
        "problemSetProblemId": "1767420176121925667",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst int N=1020,inf=0x3f3f3f3f;\n \nint g[N][N],dist[N],vis[N];\nint m,n,k,ds;\n \nvoid dijkstra(int x)\n{\n    memset(dist,inf,sizeof dist);\n    memset(vis,0,sizeof vis);\n    dist[x]=0;\n    for(int i=1;i<=n+m;i++)\n    {\n        int t=-1;\n        for(int j=1;j<=n+m;j++)\n            if(!vis[j]&&(t==-1||dist[j]<dist[t]))\n                t=j;\n        vis[t]=1;\n        for(int j=1;j<=n+m;j++)\n                dist[j]=min(dist[j],dist[t]+g[t][j]);\n    }\n}\nint main()\n{\n    cin>>n>>m>>k>>ds;\n    memset(g,inf,sizeof g);\n    while(k--)\n    {\n        string s1,s2;\n        int x,a,b;\n        cin>>s1>>s2>>x;\n        if(s1[0]=='G')\n        {\n            s1=s1.substr(1);\n            a=stoi(s1)+n;\n        }\n        else a=stoi(s1);\n        if(s2[0]=='G')\n        {\n            s2=s2.substr(1);\n            b=stoi(s2)+n;\n        }\n        else b=stoi(s2);\n        g[a][b]=g[b][a]=x;\n    }\n    int id=0;\n    double mindis=0,avedis=0;\n    for(int k=n+1;k<=n+m;k++)\n    {\n        dijkstra(k);//求出每一个垃圾箱到其他点的最短距离\n        int sumdis=0,minn=inf,t=0;\n        for(int i=1;i<=n;i++)\n        {\n            if(dist[i]>ds)\n            {\n                t=1;\n                break;\n            }\n            sumdis+=dist[i];\n            if(minn>dist[i]) minn=dist[i];\n        }\n        if(t) continue;\n        if(mindis<minn)//找出所有居民点的最短距离最长的地方\n        {\n            mindis=minn;\n            id=k;\n            avedis=sumdis*1.0/n;\n        }\n        else if(mindis==minn)//找出到所有居民点的平均距离最短的那个解\n        {\n            if(avedis>sumdis*1.0/n)\n            {\n                avedis=sumdis*1.0/n;\n                id=k;\n            }\n        }\n    }\n    if(!id) cout<<\"No Solution\";\n    else\n    {\n        cout<<'G'<<id-n<<endl;\n        printf(\"%.1lf %.1lf\",mindis,avedis);\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925668": {
        "problemSetProblemId": "1767420176121925668",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k1, k2, SLength, LLength, SWidth, LWidth, res, dif, D1, D2, a, b;\nvector<pair<int, int>> A(10), B(10);\nvoid deal(const vector<pair<int, int>> &C, const int &l) {\n\tres = SLength = LLength = SWidth = LWidth = 0;\n\tfor (int i = 0; i < l; i++) {\n\t\tif (C[i].first == C[(i + 1) % l].first) {\n\t\t\tres++;\n\t\t\tdif = abs(C[i].second - C[(i + 1) % l].second);\n\t\t\tif (dif > LLength) SLength = LLength, LLength = dif;\n\t\t\telse SLength = dif;\n\t\t} else if (C[i].second == C[(i + 1) % l].second) {\n\t\t\tres++;\n\t\t\tdif = abs(C[i].first - C[(i + 1) % l].first);\n\t\t\tif (dif > LWidth) SWidth = LWidth, LWidth = dif;\n\t\t\telse SWidth = dif;\n\t\t}\n\t}\n}\nstring judge() {\n\tif (k1 > 5 || k2 > 5) return \"NO\";\n\tif (k1 == 4 && k2 == 4) {\n\t\tdeal(A, k1);\n\t\tif (res == 4) {\n\t\t\tD1 = LLength, D2 = LWidth;\n\t\t\tdeal(B, k2);\n\t\t\tif (res != 4) return \"NO\";\n\t\t\tif (D1 == LLength || D2 == LWidth || D2 == LLength || D1 == LWidth) return \"YES\";\n\t\t} else if (res == 3) {\n\t\t\tif (SWidth == 0) D1 = LWidth, D2 = LLength - SLength;\n\t\t\telse  D1 = LLength, D2 = LWidth - SWidth;\n\t\t\tdeal(B, k2);\n\t\t\tif (res != 3) return \"NO\";\n\t\t\tif (SWidth == 0 && D1 == LWidth && D2 == LLength - SLength) return \"YES\";\n\t\t\telse if (SLength == 0 && D1 == LLength && D2 == LWidth - SWidth) return \"YES\";\n \n\t\t}\n\t\treturn \"NO\";\n\t}\n\tif (k2 > k1) swap(k1, k2), swap(A, B);\n\tdeal(A, k1);\n\tif (res != k1 - 1) return \"NO\";\n\tD1 = LLength - SLength, D2 = LWidth - SWidth;\n\tdeal(B, k2);\n\tif (res != k2 - 1) return \"NO\";\n\tif ((D1 == LLength  && D2 == LWidth) || (D2 == LLength && D1 == LWidth)) return \"YES\";\n\treturn \"NO\";\n}\nint main() {\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> k1;\n\t\tfor (int i = 0; i < k1; i++) cin >> A[i].first >> A[i].second;\n\t\tcin >> k2;\n\t\tfor (int i = 0; i < k2; i++) cin >> B[i].first >> B[i].second;\n\t\tcout << judge() << '\\n';\n\t}\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925669": {
        "problemSetProblemId": "1767420176121925669",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#define max 100000000\nusing namespace std;\nint ll[1000],mm[1000],f,g,l2[1000];\nvoid print(int a)//递归输出\n{\n    if(a==f)\n    {\n        cout<<a;\n        return;\n    }\n    print(ll[a]);\n    cout<<\" => \"<<a;\n}\nvoid print2(int a)//递归输出\n{\n    if(a==f)\n    {\n        cout<<a;\n        return;\n    }\n    print2(l2[a]);\n    cout<<\" => \"<<a;\n}\nint main()\n{\n    int a[1000][1000],b[1000][1000],c[1000],d[1000],e,h,i,j,k,l,m,n,o,p,q,vis[1000]={0},flag=0;\n    for(e=0;e<1000;e++)//初始化\n        for(f=0;f<1000;f++)\n        {\n            a[e][f]=max;\n            b[e][f]=max;\n            c[f]=max;\n            d[f]=max;\n        }\n    cin>>e>>f;\n    while(f--)\n    {\n        cin>>i>>j>>k>>l>>m;\n        if(k)\n        {\n            a[i][j]=l;\n            b[i][j]=m;\n        }\n        else\n        {\n            a[i][j]=a[j][i]=l;\n            b[i][j]=b[j][i]=m;\n        }\n    }\n    cin>>f>>g;\n    c[f]=0;\n    d[f]=0;\n    for(h=0;h<e;h++)\n    {\n        i=-1;\n        j=max;\n        for(k=0;k<e;k++)\n        {\n            if(!vis[k]&&j>c[k])\n            {\n                i=k;\n                j=c[k];\n            }\n        }\n        vis[i]=1;\n        for(k=0;k<e;k++)//Dijkstra算法\n        {\n            if(!vis[k]&&c[k]>c[i]+b[i][k])\n            {\n                c[k]=c[i]+b[i][k];//记录最小时间\n                d[k]=d[i]+a[i][k];//记录最短路程\n                ll[k]=i;//记录路径\n                mm[k]=mm[i]+1;//记录结点数，下同\n            }\n            else if(!vis[k]&&c[k]==c[i]+b[i][k]&&d[k]>d[i]+a[i][k])//时间相同时，取路径最短的路\n            {\n                c[k]=c[i]+b[i][k];\n                d[k]=d[i]+a[i][k];\n                ll[k]=i;\n                mm[k]=mm[i]+1;\n            }\n            else if(!vis[k]&&c[k]==c[i]+b[i][k]&&d[k]==d[i]+a[i][k]&&mm[k]>mm[i]+1)//时间长度相同时，判断结点数\n            {\n                c[k]=c[i]+b[i][k];\n                d[k]=d[i]+a[i][k];\n                ll[k]=i;\n                mm[k]=mm[i]+1;\n            }\n        }\n    }\n    for(i=0;i<1000;i++)\n    {\n        d[i]=max;\n        vis[i]=0;\n        mm[i]=0;\n    }\n    d[f]=0;\n    for(h=0;h<e;h++)//也是Dijkstra算法，比求最短时间的少了一个步骤\n    {\n        i=-1;\n        j=max;\n        for(k=0;k<e;k++)\n        {\n            if(!vis[k]&&j>d[k])\n            {\n                i=k;\n                j=d[k];\n            }\n        }\n        vis[i]=1;\n        for(k=0;k<e;k++)\n        {\n            if(!vis[k]&&d[k]>d[i]+a[i][k])\n            {\n                d[k]=d[i]+a[i][k];\n                l2[k]=i;\n                mm[k]=mm[i]+1;\n            }\n            else if(!vis[k]&&d[k]==d[i]+a[i][k]&&mm[k]>mm[i]+1)\n            {\n                d[k]=d[i]+a[i][k];\n                l2[k]=i;\n                mm[k]=mm[i]+1;\n            }\n        }\n    }\n    n=g;\n    m=g;\n    while(1)//控制两种形式的输出\n    {\n        n=ll[n];\n        m=l2[m];\n        if(n!=m)flag=1;\n        if(n==f||m==f)break;\n    }\n    if(flag)\n    {\n        cout<<\"Time = \"<<c[g]<<\": \";\n        print(g);\n        cout<<endl;\n        cout<<\"Distance = \"<<d[g]<<\": \";\n        print2(g);\n        cout<<endl;\n    }\n    else\n    {\n        cout<<\"Time = \"<<c[g]<<\"; \";;\n        cout<<\"Distance = \"<<d[g]<<\": \";\n        print2(g);\n        cout<<endl;\n    }\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925670": {
        "problemSetProblemId": "1767420176121925670",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,k;//n : 总的山头数 , m行 : 每行两个山头的编号 , k 要查询的山头的编号\n//山头从1到n编号\nint vis[10001],sign[10001],level[10001],maxLevel=10001,minIndex;\nvector<vector<int>>nodes;\n//BFS层序遍历 , 找到层数最大的 且 编号最小的 山头\nvoid bfs(int s){\n    queue<int>q;\n    q.push(s);\n    vis[s]=1;\n    while(!q.empty()){\n        int now=q.front();\n        q.pop();\n        for(int i=0;i<nodes[now].size();++i){\n            int nxt=nodes[now][i];\n            if(vis[nxt]) continue;\n            q.push(nxt);\n            vis[nxt]=1;\n            level[nxt]=level[now]+1; \n            if(level[nxt]>maxLevel){ \n                maxLevel=level[nxt];\n                minIndex=nxt;\n            }else if(level[nxt]==maxLevel){\n                if(minIndex>nxt){\n                    minIndex=nxt;\n                }\n            }\n        }\n    }\n}\nint main(){\n    cin>>n>>m>>k;\n    nodes.resize(n+1);\n    for(int i=1;i<=m;++i){\n        int a,b;\n        cin>>a>>b;\n        nodes[a].push_back(b);\n        nodes[b].push_back(a);\n        sign[a]=sign[b]=1;\n    }\n    for(int i=0;i<k;++i){\n        int s;\n        cin>>s;\n        maxLevel=-1;\n        minIndex=10001;\n        fill(vis,vis+10001,0);\n        fill(level,level+10001,0);\n        if(0==sign[s]){\n            cout<<\"0\"<<endl;\n            continue;\n        }\n        bfs(s);\n        cout<<minIndex<<endl;\n    }\n    \n    return 0;\n}\n \n"
        },
        "problemId": "0"
    },
    "1767420176121925671": {
        "problemSetProblemId": "1767420176121925671",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst int N=1e5+10;\n \nint a[N],b[N],vis[N],n,tt,st[N],ans;\n \nbool check(int l,int mid,int r)\n{\n    if((b[l]-b[r])*1.0/(a[l]-a[r])>=(b[mid]-b[l])*1.0/(a[mid]-a[l])) return true;\n    else return false;\n}\nint main()\n{\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n    for(int i=0;i<n;i++)\n    {\n        if(tt)//栈不为空\n        {\n            while(tt>1&&check(i,st[tt],st[tt-1])) tt--;//栈中元素大于一个，并且不是凸点\n            if(tt!=1&&!vis[st[tt]])//有凸点\n            {\n                vis[st[tt]]=1;\n                ans++;\n            }\n        }\n        st[++tt]=i;//进栈\n    }\n    cout<<ans;\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925672": {
        "problemSetProblemId": "1767420176121925672",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#define maxn 1048580\nusing namespace std;\nint tree[maxn];\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint maxx = 0;\n\tfor(int i = 0; i < n; i ++){\n\t\tint x;\n\t\tcin >> x;\n\t\tint now = 1;\n\t\twhile(tree[now]){\n\t\t\tif(x > tree[now])\n\t\t\t\tnow = now * 2;\n\t\t\telse \n\t\t\t\tnow = now * 2 + 1;\n\t\t}\n\t\tif(now > maxx)\n\t\t\tmaxx = now;\n\t\ttree[now] = x;\n\t}\n\tbool flg = true;\n\tfor(int i = 1; i <= maxx; i ++){\n\t\tif(tree[i]){\n\t\t\tif(i != 1)\n\t\t\t\tcout << \" \";\n\t\t\tcout << tree[i];\n\t\t}\n\t\telse\n\t\t\tflg = false;\n\t}\n\tcout << endl;\n\tif(flg)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925673": {
        "problemSetProblemId": "1767420176121925673",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 200 + 10;\nmap<string,int> mp;\t\t\t\t\t//建立映射，便于查找字符串和顶点序号的关系 \n \nint n, k, w;\t\t\t\t\t\t//w代表权值 \nstruct edge{\n    int to,cost;\n};\nvector <edge> G[maxn];\nint num[maxn];///每个城镇敌军数量\n \nint dis[maxn];///最短距离\nint cnt[maxn];///解放城镇数量\nint sumnum[maxn];///能杀伤多少敌军\nint pred[maxn];///记录路，pred[i]表示i的上一个节点序号 \nint cntshort[maxn];///到某一个顶点的，最短路条数\nint book[maxn];\nvector <int> ljd;\nint s, des;\n\nvoid dijsk()\n{\n\t//初始化无穷大 \n\tfor(int i = 0;i < n;i++)\n\t\tdis[i] = INF;\n\t//再根据边的情况初始化dis数组 \n\tdis[s] = 0;\n\tcntshort[s] = 1;\t\t\t\t\t\t//这句话暂时不懂？\n\tbook[s] = 1;\n\t//查看起点所有可以出去的边 \n\tfor(int i = 0;i < G[s].size();i++)\n\t{\n\t\tint next = G[s][i].to;\t\t\t\t//这条边s能到的点 \n\t\tdis[next] = G[s][i].cost;\t\t\t//记录下它的权值\n\t\t//下面三句之前弄掉了，导致答案不对 \n\t\tcntshort[next] = 1;\t\t\t\t\t//这里最短路径的条数就变成1\n\t\tsumnum[next] = num[next];\t\t\t//这里杀伤的敌军数要初始化 \n\t\tpred[next] = s;\t\t\t\t\t\t//这里next节点的前一个是s节点 \n\t}\n\t//现在dis数组已经初始化完毕！开始dijsk核心语句 \n\tint min, minindex;\n\tfor(int i = 1;i <= n - 1;i++)\t\t//n为节点个数 \n\t{\n\t\tmin = INF;\n\t\tminindex = 0;\n\t\tfor(int i = 0;i < n;i++)\t\t//遍历dis数组，找出dis值最小的那个节点 \n\t\t{\n\t\t\tif(dis[i] < min && book[i] != 1)\t\t//不能是最短路已经确定好的点 \n\t\t\t{\n\t\t\t\tmin = dis[i];\n\t\t\t\tminindex = i;\n\t\t\t}\n\t\t} \n\t\tbook[minindex] = 1;\n\t\t//对minindex这个点进行出边 \n\t\tfor(int i = 0;i < G[minindex].size();i++)\n\t\t{\n\t\t\tedge& e = G[minindex][i];\t\t\t//这个边挑出来 \n\t\t\tint d2 = dis[minindex] + e.cost;\t//待更新的距离 \n\t\t\t//如果可以松弛，就更新dis值 \n\t\t\tif(dis[e.to] > d2)\n\t\t\t{\n\t\t\t\tdis[e.to] = d2;\t\t\t\t\t//dis更新\n\t\t\t\tpred[e.to] = minindex;\t\t\t//路径更新\n\t\t\t\tcnt[e.to] = cnt[minindex] + 1;\t//解放城市数量加 1\n\t\t\t\tsumnum[e.to] = sumnum[minindex] + num[e.to];\t\t//杀死军队数更新\n\t\t\t\tcntshort[e.to] = cntshort[minindex]; \t//最短路条数 \n\t\t\t}\n\t\t\telse if(dis[e.to] == d2)\n\t\t\t{\n\t\t\t\tcntshort[e.to] += cntshort[minindex];\t\t//之和\n\t\t\t\tif(cnt[e.to] < cnt[minindex] + 1)\t\t//如果解放城市多\n\t\t\t\t{\n\t\t\t\t\t//那么路径要更新，解放城市数要更新，消灭敌军数也更新 \n\t\t\t\t\tpred[e.to] = minindex;\n\t\t\t\t\tcnt[e.to] = cnt[minindex] + 1;\n\t\t\t\t\tsumnum[e.to] = sumnum[minindex] + num[e.to];\n\t\t\t\t} \n\t\t\t\telse if(cnt[e.to] == cnt[minindex] + 1)\t//若解放城市数也相等\n\t\t\t\t{\n\t\t\t\t\t//那么看消灭的敌军数\n\t\t\t\t\tif(sumnum[e.to] < sumnum[minindex] + num[e.to])\n\t\t\t\t\t{\n\t\t\t\t\t\tsumnum[e.to] = sumnum[minindex] + num[e.to];\n\t\t\t\t\t\tpred[e.to] = minindex;\n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\t//更新完之后回到上面，继续寻找下一个minindex即可 \n\t}\n}\n\nvoid dfs(int *p, int x,vector <int>& a)\n{\n\t//反着搜，从目标des开始，递归边界就是x == s的时候 \n\tif(x == s)\n\t{\n\t\ta.push_back(x);\n\t\treturn ;\n\t}\n\tdfs(p, p[x], a);\t\t\t//递归思想：先把我前面的节点装到向量a中去 \n\ta.push_back(x);\t\t\t\t//再把我装进去 \n}\n\nint main()\n{\n\tstring city[maxn];\n\tstring city1, city2;\n\tcin >> n >> k >> city1 >> city2;\t\t//输入城镇数，道路数，起点城市和终点城市\n\t\n\tcity[0] = city1; \t\t\t\t\t\t//city数组存代表城市的字符串\n\tmp[city1] = 0;\t\t\t\t\t\t\t//建立一个string 与下标的映射？\n\t\n\t//输入各城市军队的数量 \n\tfor(int i = 1;i < n;i++)\n\t{\n\t\tcin >> city[i] >> w;\n\t\tmp[city[i]] = i;\t\t\t\t\t//建立映射，便于查找 \n\t\tnum[i] = w;\t\t\t\t\t\t\t//存储军队的个数 \n\t}\n\t//开始城市的序号，目标城市的序号 \n\ts = 0;\n\tdes = mp[city2];\t\t\t\t\n\t\n\tint u, v;\n\t//开始输入边，i从0开始 \n\tfor(int i = 0;i < k;i++)\n\t{\n\t\tcin >> city1 >> city2 >> w;\n\t\tu = mp[city1];\tv = mp[city2];\t\t//把字符串利用map翻译成点的序号 \n\t\t//将边的信息存到邻接表中，与以前的操作一样 \n\t\tG[u].push_back((edge){v, w});\t\t//(edge)强转u对应的to节点是-->v \n\t\tG[v].push_back((edge){u, w});\n\t} \n\t//输入完成之后，就可以开始Dijsk算法\n\tdijsk(); \n\tdfs(pred, des, ljd);\n\tcout<<city[0];\t\t\t//首先输出起点 \n    for(int i = 1;i<ljd.size();++i){\t\t//ljd[0] = s;\n        cout<<\"->\"<<city[ljd[i]];\n    }\n\tprintf(\"\\n%d %d %d\",cntshort[des],dis[des],sumnum[des]);\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925674": {
        "problemSetProblemId": "1767420176121925674",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n    double x, y1, y2;\n    bool friend operator < (const node &a, const node &b) {\n        return a.x < b.x;\n    }\n}Fruit[10000];\nint n, hx, hy;\ndouble kmax, kmin, tkmax, tkmin;\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> Fruit[i].x >> Fruit[i].y1 >> Fruit[i].y2;\n    sort(Fruit, Fruit + n);\n    for (int i = 0, j; i < n; i++) {\n        kmax = 1e9, kmin = -1e9;\n        for (j = 0; j < n; j++) {\n            if (i == j) continue;\n            if (i < j) {\n                tkmax = (Fruit[j].y1 - Fruit[i].y2) / (Fruit[j].x - Fruit[i].x);\n                tkmin = (Fruit[j].y2 - Fruit[i].y2) / (Fruit[j].x - Fruit[i].x);\n            } else {\n                tkmax = (Fruit[i].y2 - Fruit[j].y2) / (Fruit[i].x - Fruit[j].x);\n                tkmin = (Fruit[i].y2 - Fruit[j].y1) / (Fruit[i].x - Fruit[j].x);\n            }\n            if (tkmax < kmin || tkmin > kmax) break;\n            if (tkmax < kmax) {\n                kmax = tkmax;\n                hx = Fruit[j].x;\n                hy = Fruit[j].y1;\n            }\n            kmin = max(kmin, tkmin);\n        }\n        if (j == n) {\n            cout << hx << ' ' << hy << ' ' << (int)Fruit[i].x << ' ' << (int)Fruit[i].y2;\n            break;\n        }\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925675": {
        "problemSetProblemId": "1767420176121925675",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nconst double g=9.80;\nint main()\n{\n\tdouble E=1000,m=0,sum=0;\n\tint w=0,p=0;\n\tscanf(\"%d %d\",&w,&p);\n\tm=w*1.0/100;\n\tdouble vv=E*2.0/m;//速度的平方;\n\tdouble Sx=vv*1.0/(2.0*g);\n\twhile(E>=1e-9)\n\t{\n\t\tsum=sum+2*Sx;\n\t\tE=E-E*(p*1.0/100);\n\t\tvv=(E*2)/m;\n\t\tSx=vv/(2*g);\n\t}\n\tprintf(\"%.3lf\",sum);\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925676": {
        "problemSetProblemId": "1767420176121925676",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//Constant area\nconst int MAXN=1000000;\nconst int MIN_INF=0x80000000;\nconst int MAX_INF=0x7fffffff;\n//Variable area\nint n,te,m,st,ed,e;\n//链式前向星起手4数组\nint beg[20010];\nint to[200100];\nint nex[200100];\nint weight[200100];\n//标记该边隶属于哪条线路\nint type[200100];\nint tmp[105];\nint path[10005];//记录路径\nint take[10005];//记录这条路径经过的路线\nint disw[10005];//记录最短距离\nbool vis[10005];\nint huancheng[10005];//记录换乘次数\nvector<int> types;\nvector<int> names;\nstruct p{\n\tint self;\n\tint val;\n\tbool operator <(const p &b)const{\n\t\treturn val>b.val;\n\t}\n};\npriority_queue<p> q;\n//Initialization area\nvoid init(){\n\te=0;\n\tmemset(beg,-1,sizeof(beg));\n    return;\n}\n//Function area\n\nvoid add(int x,int y,int t,int ty){\n\tnex[++e]=beg[x];\n\tbeg[x]=e;\n\tto[e]=y;\n\tweight[e]=t;\n\ttype[e]=ty;\n}\nvoid dijkstra(){\n\tmemset(vis,0,sizeof(vis));\n\tmemset(disw,0x3f3f3f3f,sizeof(disw));\n\tmemset(path,-1,sizeof(path));\n\tmemset(take,-1,sizeof(take));\n\tmemset(huancheng,0x3f3f3f3f,sizeof(huancheng));\n\tdisw[st]=0;\n\thuancheng[st]=0;\n\tq.push({st,0});\n\twhile(q.size()){\n\t\tp now=q.top();\n\t\tq.pop();\n\t\tif(vis[now.self])\n\t\t\tcontinue;\n\t\tvis[now.self]=true;\n\t\tfor(int i=beg[now.self];i!=-1;i=nex[i]){\n\t\t\tint too=to[i];\n\t\t\tif(disw[too]>disw[now.self]+weight[i]){\n\t\t\t\tdisw[too]=disw[now.self]+weight[i];\n\t\t\t\tpath[too]=now.self;\n\t\t\t\ttake[too]=type[i];\n\t\t\t\tif(now.self==st||take[too]==take[now.self])\n\t\t\t\t    huancheng[too]=huancheng[now.self];\n\t\t\t\telse\n\t\t\t\t    huancheng[too]=huancheng[now.self]+1;\n\t\t\t\tq.push({too,disw[too]});\n\t\t\t}else if(disw[too]==disw[now.self]+weight[i]){\n\t\t\t\tif(now.self==st||take[now.self]==type[i]){\n\t\t\t\t\tif(huancheng[too]>huancheng[now.self]){\n\t\t\t\t\t\thuancheng[too]=huancheng[now.self];\n\t\t\t\t\t\tpath[too]=now.self;\n\t\t\t\t\t\ttake[too]=type[i];\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(huancheng[too]>huancheng[now.self]+1){\n\t\t\t\t\t\thuancheng[too]=huancheng[now.self]+1;\n\t\t\t\t\t\tpath[too]=now.self;\n\t\t\t\t\t\ttake[too]=type[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(disw[ed]!=0x3f3f3f3f){\n\t\tcout<<disw[ed]<<endl;\n\t\tnames.clear();\n\t\ttypes.clear();\n\t\tint lasttype=-2;\n\t\tfor(int i=ed;i!=-1;i=path[i]){\n\t\t\tif(take[i]!=lasttype){\n\t\t\t\tnames.push_back(i);\n\t\t\t\ttypes.push_back(take[i]);\n\t\t\t\tlasttype=take[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=types.size()-1;i!=0;i--)\n\t\t\tprintf(\"Go by the line of company #%d from %04d to %04d.\\n\",types[i-1],names[i],names[i-1]);\n\t}\n\telse\n\t\tprintf(\"Sorry, no line is available.\\n\");\n}\nint main(){\n    init();\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>te;\n\t\tcin>>tmp[1];\n\t\tfor(int j=2;j<=te;j++){\n\t\t\tcin>>tmp[j];\n\t\t\tadd(tmp[j],tmp[j-1],1,i);\n\t\t\tadd(tmp[j-1],tmp[j],1,i);\n\t\t}\n\t}\n\tcin>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>st>>ed;\n\t\tdijkstra();\n\t}\n}\n\n"
        },
        "problemId": "0"
    },
    "1767420176121925677": {
        "problemSetProblemId": "1767420176121925677",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\n#include <vector>\n\n#define WIN(Ti, Tj) (graph[Ti][Tj] == 'W' || graph[Tj][Ti] == 'L')\n\nchar **graph;\n\nbool dfs(int start, vector<int>& chain, bool *collected, int n) {\n\tint size = (int)chain.size();\n\tint chainLastTeam = chain[size - 1]; //chain is never empty in this function\n\tif (size == n) {\n\t\tif (WIN(chainLastTeam, start)) return true;\n\t}\n\tbool flag = true;\n\tfor (int team = 0; team < n; team++)\n\t\tif (!collected[team])\n\t\t\tif (WIN(team, start)) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\tif (flag) return false;\n\tfor (int team = 0; team < n; team++) {\n\t\tif (!collected[team] && WIN(chainLastTeam, team)) {\n\t\t\tchain.push_back(team);\n\t\t\tcollected[team] = true;\n\t\t\tif (dfs(start, chain, collected, n)) return true;\n\t\t\tchain.pop_back();\n\t\t\tcollected[team] = false;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tgraph = new char *[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tgraph[i] = new char[n];\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcin >> graph[i][j];\n\t}\n\tvector<int> chain;\n\tbool *collected = new bool[n];\n\tfill(collected, collected + n, false);\n\tfor (int team = 0; team < n; team++) {\n\t\tchain.push_back(team);\n\t\tcollected[team] = true;\n\t\tif (dfs(team, chain, collected, n)) break;\n\t\tchain.pop_back();\n\t\tcollected[team] = false;\n\t}\n\tfree(collected);\n\tfor (int i = 0; i < n; i++) {\n\t\tfree(graph[i]);\n\t}\n\tfree(graph);\n\tif (chain.empty()) {\n\t\tcout << \"No Solution\" << endl;\n\t}\n\telse {\n\t\tfor (auto it = chain.begin(); it != chain.end(); it++) {\n\t\t\tif (it != chain.begin()) putchar(' ');\n\t\t\tcout << (*it) + 1;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925678": {
        "problemSetProblemId": "1767420176121925678",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n\tint num, lchild, rchild, parent, level;\n\tnode() {\n\t\tlchild = rchild = parent = -1;\n\t}\n}Tree[128];\nint n, m, a, b, in, cnt, root = 1, f;\nmap<int, int> Find;\nstring t;\nvoid insert(int x) {\n\tint now = root;\n\twhile(Tree[now].num != x) {\n\t\tif (x < Tree[now].num) {\n\t\t\tif (Tree[now].lchild == -1) {\n\t\t\t\tTree[cnt].num = x;\n\t\t\t\tTree[cnt].level = Tree[now].level + 1;\n\t\t\t\tTree[cnt].parent = now;\n\t\t\t\tTree[now].lchild = cnt;\n\t\t\t}\n\t\t\tnow = Tree[now].lchild;\n\t\t} else {\n\t\t\tif (Tree[now].rchild == -1) {\n\t\t\t\tTree[cnt].num = x;\n\t\t\t\tTree[cnt].level = Tree[now].level + 1;\n\t\t\t\tTree[cnt].parent = now;\n\t\t\t\tTree[now].rchild = cnt;\n\t\t\t}\n\t\t\tnow = Tree[now].rchild;\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n >> in;\n\tTree[++cnt].num = in;\n\tFind[in] = cnt;\n\tfor (int i = 1; i < n; i++) {\n\t\tcin >> in;\n\t\tFind[in] = ++cnt;\n\t\tinsert(in);\n\t}\n\tcin >> m;\n\twhile (m--) {\n\t\tf = 0;\n\t\tcin >> a >> t;\n\t\tif (t == \"is\") {\n\t\t\tcin >> t >> t;\n\t\t\tif (t == \"root\") {\n\t\t\t\tif (Find[a] == root) f = 1;\n\t\t\t} else if (t == \"parent\") {\n\t\t\t\tcin >> t >> b;\n\t\t\t\tif (Tree[Find[b]].parent == Find[a]) f = 1;\n\t\t\t} else if (t == \"left\") {\n\t\t\t\tcin >> t >> t >> b;\n\t\t\t\tif (Tree[Find[b]].lchild == Find[a]) f = 1;\n\t\t\t} else {\n\t\t\t\tcin >> t >> t >> b;\n\t\t\t\tif (Tree[Find[b]].rchild == Find[a]) f = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tcin >> b >> t >> t;\n\t\t\tif (t == \"siblings\") {\n\t\t\t\tif (Find[a] && Find[b] && Tree[Find[a]].parent == Tree[Find[b]].parent) f = 1;\n\t\t\t} else {\n\t\t\t\tcin >> t >> t >> t;\n\t\t\t\tif (Find[a] && Find[b] && Tree[Find[a]].level == Tree[Find[b]].level) f = 1;\n\t\t\t}\n\t\t}\n\t\tcout << (f ? \"Yes\" : \"No\") << '\\n';\n\t}\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925679": {
        "problemSetProblemId": "1767420176121925679",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int M = 1e6 + 10;\nconst int MAX = 0x3f3f3f3f;\nint n, m ,a[M];\npair<int, int> v[M];\nll tree[M * 8], tag[M * 8];\n \nvoid push_down(int p)//传递函数\n{\n    tag[p * 2] += tag[p];\n\ttag[p * 2 + 1] += tag[p];\n\ttree[p * 2] -= tag[p];\n\ttree[p * 2 + 1] -= tag[p];\n\ttag[p] = 0;\n}\n \nvoid bulid(int p, int pl, int pr) //表示建线段树\n{\n\tif (pl == pr)\n\t{\n\t\ttree[p] = a[pl];\n\t\treturn;\n\t}\n\tint mid = (pl + pr) / 2;\n\tbulid(p * 2, pl, mid);\n\tbulid(p * 2 + 1, mid + 1, pr);\n\ttree[p] = min(tree[p * 2], tree[p * 2 + 1]);\n}\n \nll query(int L, int R, int p, int pl, int pr)//查询某个区间[L, R]内的最小值\n{\n\tif (L <= pl && pr <= R)\n\t\treturn tree[p];\n\tif (tag[p])\n\t\tpush_down(p);\n\tint mid = (pl + pr) / 2;\n\tll res = 1e18;\n\tif (mid >= L)\n\t\tres = min(res, query(L, R, p * 2, pl, mid));\n\tif (mid < R)\n\t\tres = min(res, query(L, R, p * 2 + 1, mid + 1, pr));\n\treturn res;\n}\n \nvoid update(int L, int R, int p, int pl, int pr, ll d)//区间修改函数\n{\n\tif (L <= pl && R >= pr)\n\t{\n\t\ttag[p] += d;\n\t\ttree[p] -= d;\n\t\treturn;\n\t}\n\tif (tag[p])\n\t\tpush_down(p);\n\tint mid = (pl + pr) / 2;\n\tif (L <= mid)\n\t\tupdate(L, R, p * 2, pl, mid, d);\n\tif (mid < R)\n\t\tupdate(L, R, p * 2 + 1, mid + 1, pr, d);\n\ttree[p] = min(tree[p * 2], tree[p * 2 + 1]);\n}\n \nint main()\n{\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n - 1; i++)\n\t\tcin >> a[i];\n\tbulid(1, 1, n - 1);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif (l > r)\n\t\t\tswap(l, r);\n\t\tv[i] = {r, l};\n\t}\n\tsort(v, v + m);\n\tll ans = 0;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tll sum = query(v[i].second + 1, v[i].first, 1, 1, n - 1);\n\t\tans += sum;\n\t\tupdate(v[i].second + 1, v[i].first, 1, 1, n - 1, sum);\n\t} \n\tcout << ans;\n\treturn 0;\n}\n "
        },
        "problemId": "0"
    },
    "1767420176121925680": {
        "problemSetProblemId": "1767420176121925680",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <queue>\n#include <cmath>\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef pair<pair<int,int>,double> paa;\nconst double r = sqrt(2) - 1;\nint n,m;\nint sx,sy,ex,ey;\ndouble mp[101][101];\nint flag;\nint dir[8][2] = {0,1,1,0,0,-1,-1,0,-1,-1,1,-1,-1,1,1,1};\nint cc[101][101];\ndouble rr[8] = {0,0,0,0,r,r,r,r};\nint check(int x,int y) {\n    int d = (sx - x) * (ey - y) - (ex - x) * (sy - y);\n    if(d) return d / abs(d);\n    return 0;\n}\ndouble bfs() {\n    bool vis[101][101] = {false};\n    double msum[101][101];\n    for(int i = 0;i < n;i ++) {\n        for(int j = 0;j < m;j ++) {\n            msum[i][j] = inf;\n        }\n    }\n    msum[sx][sy] = mp[sx][sy];\n    queue<paa> q;\n    q.push(paa(pa(sx,sy),mp[sx][sy]));\n    while(!q.empty()) {\n        int x = q.front().first.first;\n        int y = q.front().first.second;\n        double sum = q.front().second;\n        q.pop();\n        for(int i = 0;i < 8;i ++) {\n            int tx = x + dir[i][0];\n            int ty = y + dir[i][1];\n            if(tx < 0 || ty < 0 || tx >= n || ty >= m || cc[tx][ty] != flag) continue;\n            double tsum = sum + mp[tx][ty] + rr[i] * (mp[x][y] + mp[tx][ty]);\n            if(tsum < msum[tx][ty]) {\n                q.push(paa(pa(tx,ty),msum[tx][ty] = tsum));\n            }\n        }\n    }\n    return msum[ex][ey];\n}\nint main() {\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 0;i < n;i ++) {\n        for(int j = 0;j < m;j ++) {\n            scanf(\"%lf\",&mp[i][j]);\n        }\n    }\n    scanf(\"%d%d%d%d\",&sy,&sx,&ey,&ex);\n    for(int i = 0;i < n;i ++) {\n        for(int j = 0;j < m;j ++) {\n            cc[i][j] = check(i,j);\n        }\n    }\n    double ans = 0 - mp[sx][sy] - mp[ex][ey];\n    cc[sx][sy] = cc[ex][ey] = flag = 1;\n    ans += bfs();\n    cc[sx][sy] = cc[ex][ey] = flag = -1;\n    ans += bfs();\n    printf(\"%.2f\",ans);\n}"
        },
        "problemId": "0"
    },
    "1767420176121925681": {
        "problemSetProblemId": "1767420176121925681",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nint point, space = 2, mark, tp, cnt, use, temp;\nstring s;\nint Function(int c) {\n    if (c == 0) while (s[point] == ' ') point++;\n    else if (c == 1) for (int i = 0; i < space; i++) cout << ' ';\n    else if (c == 2) {\n        if (s.substr(point, 2) == \"if\" && (s[point + 2] == '(' || s[point + 2] == ' ')) return 2;\n        else if (s.substr(point, 3) == \"for\" && (s[point + 3] == '(' || s[point + 3] == ' ')) return 3;\n        else if (s.substr(point, 4) == \"else\" && (s[point + 4] == '(' || s[point + 4] == ' ')) return 4;\n        else if (s.substr(point, 5) == \"while\" && (s[point + 5] == '(' || s[point + 5] == ' ')) return 5;\n    } else if (c == 3) {\n        Function(0);\n        if (Function(2) == 4) return 0;\n        while (mark) {\n            space -= 2;\n            Function(1);\n            cout << \"}\\n\";\n            mark--;\n        } \n    }\n    return 0;\n}\nint main() {\n    getline(cin, s);\n    Function(0);\n    for (int i = point; s[i] != ')'; i++) cout << s[i];\n    cout << \")\\n{\\n\";\n    point = s.find('{') + 1;\n    while (1) {\n        Function(0);\n        temp = Function(2);\n        if (s[point] == '{') {\n            Function(1);\n            cout << \"{\\n\";\n            space += 2;\n            point++;\n        } else if (s[point] == '}') {\n            space -= 2;\n            Function(1);\n            cout << \"}\\n\";\n            if (space == 0) return 0;\n            Function(3);\n            point++;\n        } else if (temp) {\n            Function(1);\n            cout << s.substr(point, temp);\n            point += temp;\n            if (temp != 4) {\n                Function(0);\n                tp = point;\n                cnt = 0;\n                while(tp < s.size()) {\n                    if (s[tp] == '(') cnt++;\n                    else if (s[tp] == ')') cnt--;\n                    tp++;\n                    if (cnt == 0) break;\n                }\n                cout << ' ' << s.substr(point, tp - point);\n                point = tp;\n            }\n            cout <<  \" {\\n\";\n            space += 2;\n            Function(0);\n            if (s[point] != '{') {\n                use = 1;\n                mark++;\n            } else {\n                use = 0;\n                point++;\n            }\n        } else {\n            Function(1);\n            cnt = s.find(';', point);\n            cout << s.substr(point, cnt - point + 1) << '\\n';\n            point = cnt + 1;\n            if (use && mark) {\n                space -= 2;\n                Function(1);\n                cout << \"}\\n\";\n                mark--;\n                Function(3);\n            }\n        }\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925682": {
        "problemSetProblemId": "1767420176121925682",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nlong long dp[1000001][4], vis[128], last;\nint main() {\n    cin >> s;\n    for (int i = 0; i <= s.size(); i++) dp[i][0] = 1;\n    for (int i = 1; i <= s.size(); i++) {\n        last = vis[s[i - 1]];\n        vis[s[i - 1]] = i;\n        for (int j = 1; j <= 3; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];\n            if (last && j - (i - last) >= 0) dp[i][j] -= dp[last - 1][j - (i - last)];\n        }\n    }\n    cout << dp[s.size()][0] + dp[s.size()][1] + dp[s.size()][2] + dp[s.size()][3];\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925683": {
        "problemSetProblemId": "1767420176121925683",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, cnt;\nlong long ans = 1e17;\nbool cmp (const pair<long long, long long> &a, const pair<long long, long long> &b) {\n    if (a.first * b.second != b.first * a.second)\n        return a.first * b.second > b.first * a.second;\n    return a.first < b.first;\n}\nint main() {\n    scanf(\"%d\", &n);\n    vector<pair<long long, long long>> A(n), B(n - 1);\n    for (i = 0; i < n; i++) scanf(\"%lld %lld\", &A[i].first, &A[i].second);\n    for (i = 0; i < n; i++, cnt = 0) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            B[cnt++] = {A[j].first - A[i].first, A[j].second - A[i].second};\n        }\n        sort(B.begin(), B.end(), cmp);\n        for (int j = 1; j < n - 1; ++j) ans = min(ans, abs(B[j - 1].first * B[j].second - B[j].first * B[j - 1].second));\n    }\n    printf(\"%.3f\", 0.5 * ans);\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925684": {
        "problemSetProblemId": "1767420176121925684",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Mx = 1e9;\nint N, M, K, Q, from, to, dis, Ter[201], Edge[201][201];\nmap<int, set<int>> Station;\nmap<int, set<int>> Ans;\nvoid DFS(int Start, int Now) {\n    for (auto it : Station[Now]) {\n        if (Ans[Start].count(it)) continue;\n        Ans[Start].insert(it);\n        DFS(Start, it);\n    }\n}\nint main() {\n    for (int i = 1; i <= 200; i++)\n        for (int j = 1; j <= 200; j++)\n            Edge[i][j] = Mx;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    while (M--) {\n        scanf(\"%d\", &from);\n        Ter[from] = 1;\n        while (1) {\n            scanf(\"%d %d\", &dis, &to);\n            Edge[from][to] = Edge[to][from] = min(Edge[from][to], dis);\n            from = to;\n            if (getchar() == '\\n') break;\n        }\n        Ter[to] = 1;\n    }\n    for (int k = 1; k <= N; k++)\n        for (int i = 1; i <= N; i++)\n            for (int j = 1; j <= N; j++) \n                if (i != j) Edge[i][j] = min(Edge[i][j], Edge[i][k] + Edge[k][j]);\n    for (int i = 1; i <= N; i++) {\n        map<int, int> Fur_Dis;\n        Ans[i].insert(i);\n        for (int j = 1; j <= N; j++) {\n            if (Edge[i][j] != Mx) {\n                if (Ter[j] == 1) Station[i].insert(j);\n                if (Edge[i][j] > Fur_Dis[Edge[i][j] / K]) Fur_Dis[Edge[i][j] / K] = Edge[i][j];\n            }\n        }\n        for (int j = 1; j <= N; j++)\n            if (Edge[i][j] == Fur_Dis[Edge[i][j] / K]) Station[i].insert(j);\n    }\n    for (int i = 1; i <= N; i++) DFS(i, i);\n    scanf(\"%d\", &Q);\n    while (Q--) {\n        scanf(\"%d\", &from);\n        for (auto it : Ans[from]) \n            printf(\"%d%c\", it, (it != *Ans[from].rbegin()) ? ' ' : '\\n');\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925685": {
        "problemSetProblemId": "1767420176121925685",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 50000+10;\nstruct Node{\n    int op,x1,x2;\n    double v;\n}node[maxn];\nmap<int,map<int,map<int,double>>>save;//第一个参数为节点，第二个参数决定是否求导，第三个参数是对谁求导\nint have[maxn];\ndouble dfs(int id,int key,int x){\n    if(save[id][key][x]) return save[id][key][x];\n    else{\n        switch(node[id].op){\n            case 0://value\n                return save[id][key][x]=key==0?node[id].v:(id==x?1:0);\n            case 1://plus\n                return save[id][key][x]=dfs(node[id].x1,key,x)+dfs(node[id].x2,key,x);\n            case 2://minus\n                return save[id][key][x]=dfs(node[id].x1,key,x)-dfs(node[id].x2,key,x);\n            case 3://multiply\n                return save[id][key][x]=key==0?dfs(node[id].x1,0,x)*dfs(node[id].x2,0,x):dfs(node[id].x2,0,x)*dfs(node[id].x1,1,x)+dfs(node[id].x1,0,x)*dfs(node[id].x2,1,x);\n            case 4://e\n                return save[id][key][x]=key==0?exp(dfs(node[id].x1,0,x)):exp(dfs(node[id].x1,0,x))*dfs(node[id].x1,1,x);\n            case 5://ln\n                return save[id][key][x]=key==0?log(dfs(node[id].x1,0,x)):1/dfs(node[id].x1,0,x)*dfs(node[id].x1,1,x);\n            case 6://sin\n                return save[id][key][x]=key==0?sin(dfs(node[id].x1,0,x)):cos(dfs(node[id].x1,0,x))*dfs(node[id].x1,1,x);\n        }\n    }\n}\nint main(){\n    int n,root=0;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&node[i].op);\n        if(node[i].op==0) scanf(\"%lf\",&node[i].v);\n        else if(node[i].op<=3){\n            scanf(\"%d%d\",&node[i].x1,&node[i].x2);\n            have[node[i].x1]=have[node[i].x2]=1;\n        }\n        else{\n            scanf(\"%d\",&node[i].x1);\n            have[node[i].x1]=1;\n        }\n    }\n    while(have[root]==1) root++;\n    printf(\"%.3f\\n\",dfs(root,0,-1));\n    bool flag=false;\n    for(int i=0;i<n;i++){\n        if(node[i].op==0){\n            if(flag) printf(\" \");\n            printf(\"%.3f\",dfs(root,1,i));\n            flag=true;\n        }\n    }\n    return 0;\n}\n \n "
        },
        "problemId": "0"
    },
    "1767420176121925686": {
        "problemSetProblemId": "1767420176121925686",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <stdio.h>\n#include <math.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\nFILE *input, *solution, *output;\n \n#define N (20)\n#define PB push_back\n#define eps (1e-6)\ntypedef vector<int> intArray;\n \nvector<int> va[N+2], vb[N+2];\n \nstruct point {\n    double x, y;\n    point(): x(0), y(0) {}\n    point(double x, double y): x(x), y(y) {}\n    void set(const point &t) {\n        x = t.x, y = t.y;\n    }\n    void set(double _x, double _y) {\n        x = _x, y = _y;\n    }\n    void read() {\n        fscanf(input, \"%lf%lf\", &x, &y);\n    }\n} pt[N+2][N+2], a, b;\n \ninline double sqr(double x) {\n    return x*x;\n}\ninline double dis(const point &a, const point &b) {\n    return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));\n}\nint getClosest(const point &a, const point *pt, const int *f) {\n    int res = -1;\n    for (int i = 0; i < N; ++i) {\n        if (!f[i]) {\n            if (res == -1) {\n                res = i;\n            }\n            else {\n                if (dis(pt[i], a) < dis(pt[res], a)) {\n                    res = i;\n                }\n            }\n        }\n    }\n    return res;\n}\n \nconst point* splitSegment(const point &a, const point &b, double p, double q) {\n    return new point((a.x*q+b.x*p)/(p+q), (a.y*q+b.y*p)/(p+q));\n}\n \ndouble totalTime = 0;\ndouble endTime = 120;\n \ndouble getTime(const point &a, const point &b, const point *pt, const intArray &va, const intArray &vb) {\n    double ta = va.size() > 0 ? dis(a, pt[va[0]]) : 0, tb = vb.size() > 0 ? dis(b, pt[vb[0]]) : 0;\n    for (int i = 1; i < va.size(); ++i) {\n        ta += dis(pt[va[i]], pt[va[i-1]]);\n    }\n    for (int i = 1; i < vb.size(); ++i) {\n        tb += dis(pt[vb[i]], pt[vb[i-1]]);\n    }\n    return max(ta, tb) / 2;\n}\n \nint getRest(const point &a, const point &b, const point *pt, const intArray &va, const intArray &vb) {\n    double ta = va.size() > 0 ? dis(a, pt[va[0]]) / 2 : 0, tb = vb.size() > 0 ? dis(b, pt[vb[0]]) / 2 : 0;\n    double restTime = endTime - totalTime;\n    int ans = (va.size() > 0 && ta < restTime) + (vb.size() > 0 && tb < restTime);\n    int ff[30] = {};\n    \n    for (int i = 1; i < va.size(); ++i) {\n        if ((ta += dis(pt[va[i]], pt[va[i-1]]) / 2) < restTime) {\n            if (!ff[va[i]]) {\n                ans++;\n                ff[va[i]] = 1;\n            }\n        } else {\n            break;\n        }\n    }\n    for (int i = 1; i < vb.size(); ++i) {\n        if ((tb += dis(pt[vb[i]], pt[vb[i-1]]) / 2) < restTime) {\n            if (!ff[vb[i]]) {\n                ans++;\n                ff[vb[i]] = 1;\n            }\n        } else {\n            break;\n        }\n    }\n    return ans;\n}\n \nint f[N+2][N+2];\n \ndouble time = 0;\n \nvoid work(const point *pt, int f[], intArray &va, intArray &vb) {\n    int ta = -1, tb = -1, cnt = 0;\n    double disa = 0, disb = 0;\n    while (cnt < N) {\n        // a arrives at ta -> set next target\n        if (ta == -1 || (disa = dis(a, pt[ta])) < eps) {\n            disa = dis(pt[ta = getClosest(a, pt, f)], a);\n            if (ta != -1 && time + disa / 2 < endTime) {\n                f[ta] = 1;\n                va.PB(ta);\n                cnt++;\n            }\n        }\n        // b arrives at tb -> set next target\n        if (tb == - 1 || (disb = dis(b, pt[tb])) < eps) {\n            disb = dis(pt[tb = getClosest(b, pt, f)], b);\n            if (tb != -1 && time + disb / 2 < endTime) {\n                f[tb] = 2;\n                vb.PB(tb);\n                cnt++;\n            }\n        }\n        // move\n        if (disa < disb) {\n            a.set(pt[ta]);\n            b.set(*splitSegment(b, pt[tb], disa, disb-disa));\n            time += disa / 2;\n            // printf(\"a move to %f %f, b move to %f %f, time %f\\n\", a.x, a.y, b.x, b.y, time);\n        }\n        else {\n            b.set(pt[tb]);\n            a.set(*splitSegment(a, pt[ta], disb, disa-disb));\n            time += disb / 2;\n            // printf(\"a move to %f %f, b move to %f %f, time %f\\n\", a.x, a.y, b.x, b.y, time);\n        }\n    }\n    \n    a.set(pt[va[va.size() - 1]]);\n    b.set(pt[vb[vb.size() - 1]]);\n}\n \nvoid print() {\n    int n = 0;\n    for (; n < N; ++n) {\n        int ok = 0;\n        for (int j = 0; j < N; ++j) {\n            ok |= f[n][j];\n        }\n        if (!ok) {\n            break;\n        }\n    }\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", va[i].size(), vb[i].size());\n        for (int j = 0; j < va[i].size(); ++j) {\n            printf(\"%d%c\", va[i][j], \" \\n\"[j == va[i].size() - 1]);\n        }\n        for (int j = 0; j < vb[i].size(); ++j) {\n            printf(\"%d%c\", vb[i][j], \" \\n\"[j == vb[i].size() - 1]);\n        }\n    }\n}\n \nvoid my_assert(bool x, const char* err) {\n    if (!x) {\n        fprintf(stderr, \"%s\\n\", err);\n        exit(1);\n    }\n}\n \nint main(int argc, char** argv) {\n    input = fopen(\"input\", \"r\");\n    output = fopen(\"output\", \"r\");\n    solution = fopen(\"user_output\", \"r\");\n    int valve = 300;\n    fscanf(output, \"%d\", &valve);\n    my_assert(valve >= 0 && valve <= 300, \"valve should be in [0, 300]\");\n    if (input && solution) {\n        int number;\n        fscanf(input, \"%d\", &number);\n        my_assert(number >= 0 && number <= 10, \"case number should be in [0, 10]\");\n        int res = 0;\n        for (int _ = 0; _ < number; ++_) {\n            for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    pt[i][j].read();\n                    f[i][j] = 0;\n                    va[i].clear();\n                    vb[i].clear();\n                }\n            }\n            \n            int n = 0;\n            fscanf(solution, \"%d\", &n);\n            my_assert(0 <= n && n <= N, \"n should be in [0, 20]\");\n            for (int i = 0, sa, sb; i < n; ++i) {\n                fscanf(solution, \"%d%d\", &sa, &sb);\n                my_assert((sa >= 0 && sa <= N && sb >= 0 && sb <= N), \"sa and sb should be in [0, 20]\");\n                int f[N+4] = {};\n                for (int j = 0, x; j < sa; ++j) {\n                    fscanf(solution, \"%d\", &x);\n                    my_assert((x >= 0 && x < N && (f[x] & 1) == 0), \"a index range error or duplicate\");\n                    va[i].PB(x);\n                    f[x] |= 1; \n                }\n                for (int j = 0, x; j < sb; ++j) {\n                    fscanf(solution, \"%d\", &x);\n                    // assert(f[x] == 0);\n                    my_assert((x >= 0 && x < N && (f[x] & 2) == 0), \"b index range error or duplicate\");\n                    vb[i].PB(x);\n                    f[x] |= 2;\n                }\n            }\n            totalTime = 0;\n            a.set(7.0,7.0);\n            b.set(8.0,8.0);\n            for (int i = 0; i < n; ++i) {\n                totalTime += getTime(a, b, pt[i], va[i], vb[i]);\n                int tot = 0;\n                int ff[30] = {};\n                for (auto ia: va[i]) {\n                    ff[ia] = 1;\n                }\n                for (auto ib: vb[i]) {\n                    ff[ib] = 1;\n                }\n                for (int j = 0; j < 20; ++j) {\n                    tot += ff[j];\n                }\n                if (totalTime > endTime || tot < 20) {\n                    totalTime -= getTime(a, b, pt[i], va[i], vb[i]);\n                    tot = getRest(a, b, pt[i], va[i], vb[i]);\n                    printf(\"%d\\n\", tot);\n                    res += i*20 + tot;\n                    break;\n                }\n                if (va[i].size() > 0) a.set(pt[i][va[i][va[i].size() - 1]]);\n                if (vb[i].size() > 0) b.set(pt[i][vb[i][vb[i].size() - 1]]);\n            }\n            printf(\"Total time: %f\\n\", totalTime);\n        }\n        printf(\"Score: %f\\n\", res / (double) number);\n        return res < valve * number;\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925687": {
        "problemSetProblemId": "1767420176121925687",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M, S1, S2, A, B, consistency, laneNum[502];\nvector<int> Edge[502];\nint dfs(int index) {\n    if (laneNum[index] != 0) return laneNum[index];\n    for (int Next : Edge[index]) {\n        if (laneNum[Next] == 0) dfs(Next);\n        laneNum[index] += laneNum[Next];\n    }\n    if (laneNum[index] == 0) consistency = 1;\n    return laneNum[index];\n}\nint main() {\n    cin >> N >> M;\n    for (int i = 0; i < M; ++i) {\n        cin >> S1 >> S2;\n        Edge[S1].push_back(S2);\n    }\n    cin >> A >> B;\n    laneNum[B] = 1;\n    dfs(A);\n    cout << laneNum[A] << ' ' << (consistency ? \"No\" : \"Yes\");\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925688": {
        "problemSetProblemId": "1767420176121925688",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "/*\n+ 一开始初始化成n条链，传送门对应链上的结点，将所有需要新增或者删除的传送门的y值离散化，存入链上。\n+ 对于每个操作，实际上要做的是“分别查询两个结点各自所在链上的左右端点”和“将两个结点的后继结点交换”，用splay可以做到logq\n*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long  long LL;\nconst int maxn = 5e5+10, inf =1e9+10;\n\nint n, m;\nstruct node{int x1,x2,y1,y2;}qr[maxn];\nvector<int>rt[maxn];\n\n#define l(u) ch[u][0]\n#define r(u) ch[u][1]\nint fa[maxn], ch[maxn][2], tot, X[maxn];\nint sf(int u){return u== r(fa[u]);}\nbool isrt(int u){return u!=l(fa[u])&&u!= r(fa[u]);}\nvoid rot(int u){\n\tint v=fa[u],f= sf (u);\n\tif(!isrt(v))ch[fa[v]][sf(v)]= u;\n\tch[v][f]=ch[u][f^1],fa[ch[v][f]]= v;\n\tfa[u]=fa[v],ch[u][f^1]=v,fa[v]= u;\n}\nint newnode(){int u=++tot; fa[u]=l(u)=r(u)= 0 ; return u;}\nvoid splay(int u){ for(;!isrt(u); rot(u))if(!isrt(fa[u])&&sf(fa[u])==sf(u))rot(fa[u]);}\nint fdl(int u){splay(u); for(;l(u); u=l(u)); splay(u); return u;}\nint fdr(int u){splay(u); for(;r(u); u=r(u)); splay(u); return u;}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tfor(int i=1; i <= m; i++){\n\t\tchar ch;  cin>>ch;\n\t\tcin>>qr[i].x1>>qr[i].x2>>qr[i].y1;\n\t}\n\tfor(int i=1; i <= n; i++){\n\t\trt[i].push_back(0);  rt[i].push_back(inf);\n\t}\n\tfor(int i=1; i <= m; i++){\n\t\trt[qr[i].x1].push_back(qr[i].y1);\n\t\trt[qr[i].x2].push_back(qr[i].y1);\n\t}\n\tfor(int i=1; i <= n; i++){\n\t\tsort(rt[i].begin(),rt[i].end());\n\t\trt[i].resize(unique(rt[i].begin(),rt[i].end()) - rt[i].begin());\n\t}\n\tfor(int i=1; i <= m; i++){\n\t\tint y = qr[i].y1;\n\t\tqr[i].y1= lower_bound(rt[qr[i].x1].begin(),rt[qr[i].x1].end(),y)- rt[qr[i].x1].begin();\n\t\tqr[i].y2=lower_bound(rt[qr[i].x2].begin(),rt[qr[i].x2].end(),y)- rt[qr[i].x2].begin( );\n\t}\n\tfor(int i=1; i <= n; i++){\n\t\tfor(int j=0; j<rt[i].size(); j++){\n\t\t\trt[i][j]=newnode(); X[rt[i][j]]= i;\n\t\t}\n\t\tfor(int j=0; j<rt[i].size()-1; j++){\n\t\t\tr(rt[i][j])=rt[i][j+1],fa[rt[i][j+1]]= rt[i][j];\n\t\t}\n\t}\n\tLL ans=(LL)n*(n+1)*(2*n+1)/6;\n\tfor(int i=1; i <= m; i++){\n\t\tint x1=qr[i].x1,x2=qr[i].x2,y1=qr[i].y1,y2=qr[i].y2;\n\t\tint u=rt[x1][y1],v= rt[x2][y2];\n\t\tint lu=X[fdl(u)],ru=X[fdr(u)],lv=X[fdl(v)],rv= X[fdr(v)];\n\t\tans-=(LL)lu*ru+(LL)lv*rv;\n\t\tans+=(LL)lu*rv+(LL) lv*ru;\n\t\tsplay(u),splay(v);\n\t\tint u2=r(u),v2=r(v);\n\t\tr(u)=v2,r(v)=u2,fa[v2]=u,fa[u2]=v;\n\t\tcout<<ans<<\"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"
        },
        "problemId": "0"
    },
    "1767420176121925689": {},
    "1767420176121925690": {
        "problemSetProblemId": "1767420176121925690",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<cstdlib>\n#include<cstdio>\n#include<string>\n#define ll long long\n#include<stack>\n#include <vector>\n#include<unordered_map>\n#include<set>\nusing namespace std;\nconst int maxn=1e5+10;\nconst ll inf=1e18;\nint n,m,ci;//n个城市，m条路径，ci次修改修改\nbool vis1[maxn],vis2[maxn];//dijkstra所需要的，记录这个节点是否被访问过\nll dis1[maxn],dis2[maxn];\nmultiset<ll>mincost;//用于维护每个中转点的结果\nstruct node{\n\tll to,w;\n};//存储边\nstruct good{\n\tll id;//记录点\n\tll dis;//记录距离\n\tfriend bool operator <(const good&a,const good&b)//保证队列顶部是距离最小的点\n\t{\n\t\treturn a.dis>b.dis;\n\t}\n};//优先队列的元素类型\nvector<node>road1[maxn],road2[maxn];\nvoid add1(int u,ll to,ll w)//存储现金的路径\n{\n\troad1[u].push_back({to,w});\n}\nvoid add2(int u,ll to,ll w)//存储旅游金的路径\n{\n\troad2[u].push_back({to,w});\n}\npriority_queue<good>q;//优先队列\nvoid dijkstra(int start,vector<node>road[],ll dis[],bool vis[])\n{//start是起点，road[]是图，dis代表距离，vis记录是否访问过该点\n\tfor(int i=0;i<=n;++i)//初始化\n\tdis[i]=inf;\n\tdis[start]=0;//起点距离为0\n\tq.push({start,0});//加入队列\n\twhile(!q.empty())\n\t{\n\t\tint p=q.top().id;//取出第一个点\n\t\tq.pop();//删除点\n\t\tif(vis[p])\n\t\tcontinue;\n\t\tvis[p]=1;\n\t\tfor(int i=0;i<road[p].size();i++)\n\t\t{\n\t\t\tll to=road[p][i].to;\n\t\t\tll w=road[p][i].w;\n\t\t\tif(dis[to]>dis[p]+w)//放缩\n\t\t\t{\n\t\t\t\tdis[to]=dis[p]+w;\n\t\t\t\tq.push({to,dis[to]});\n\t\t\t}\n\t\t}\n\t}\n}\nll a[maxn];//记录每个点的汇率\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);//关闭同步流\ncin>>n>>m>>ci;//输入\nfor(int i=0;i<m;i++)\n{\n\tll u,to,w,w2;\n\tcin>>u>>to>>w>>w2;\n\tadd1(u,to,w);\n\tadd2(to,u,w2);\n}\nfor(int i=1;i<=n;i++)\ncin>>a[i];\ndijkstra(1,road1,dis1,vis1);\ndijkstra(n,road2,dis2,vis2);\nfor(int i=1;i<=n;i++)\nif(dis1[i]!=inf&&dis2[i]!=inf)//如果可以通过i点然后到n点\n{\n    ll ans=dis1[i]+(dis2[i]+a[i]-1)/a[i];\n\tmincost.insert(ans);//(dis2[i]+a[i]-1)/a[i]保证了如果 \n //dis2[i]不能整除a[i]时，得到的现金加1。\n}\nwhile(ci--)\n{\n\tint dian,v;//dian为修改汇率的城市，改成v。\n\tcin>>dian>>v;\n\tif(a[dian]==v||dis1[dian]==inf||dis2[dian]==inf)//如果修改的城市到不了或者v和原来的值相 \n  //比没变化\n\tcout<<*mincost.begin()<<'\\n';//输出最小值\n\telse\n\t{\n\t\tmincost.erase(mincost.find(dis1[dian]+(dis2[dian]+a[dian]-1)/a[dian]));\n            //删除该中转站所得的原本的值\n\t\ta[dian]=v;//修改汇率\n\t\tmincost.insert(dis1[dian]+(dis2[dian]+a[dian]-1)/a[dian]);//添加现在所需要的现金\n\t\tcout<<*mincost.begin()<<'\\n';//输出最小值\n\t}\n\t\n}\n\treturn 0;\n} "
        },
        "problemId": "0"
    },
    "1767420176121925691": {
        "problemSetProblemId": "1767420176121925691",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include <iostream>\n#include<string>\n#include<cmath>\n#include<vector>\n#include <queue>\n#include <iomanip>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\nint N, M;\nint arr[100005];//存储折线点的高度值\nint vi[100005] = { 0 };//表示纸片是否访问过\nvector<int> ve[105];//vector数组用来存放纸片的多个折线点高度\nvector<int>vv;//容器用来存放已经找到位置的纸片\nbool flag = true;\nvoid DFS(int i) {//深度优先\n\tif (vv.size() == M)//所有的纸片都有了对应的位置\n\t{\n\t\tflag = false;\n\t\treturn;\n\t}\n\tif (!flag)return;\n\tfor (int j = 1; j <= M; j++)\n\t{\n\t\tbool bo = true;\n\t\tif (vi[j] == 1)continue;//该纸片已经找到位置\n\t\tif (ve[j][0] == arr[i])\n\t\t{\n\t\t\tfor (int k = 0; k < ve[j].size(); k++)//判断该段是否符合纸片与纸的折线点高度一一对应\n\t\t\t{\n\t\t\t\tif (ve[j][k] != arr[i + k]) {\n\t\t\t\t\tbo = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bo) {\n\t\t\t\tvi[j] = 1;\n\t\t\t\tvv.push_back(j);//满足条件的纸片放入容器\n\t\t\t\tDFS(i + ve[j].size() - 1);//很重要的-1，所有的纸片的折线点高度比纸的折线点高度要多，因为要满足相邻两纸片之间的相邻折线处高度相同\n\t\t\t\tif (!flag)return;//纸的高度的数量=纸片高度的数量-纸片个数，表示纸片两两相邻\n\t\t\t\tvi[j] = 0;\n\t\t\t\tvv.pop_back();\n\t\t\t}\n\n\t\t}\n\t}\n}\nint main()\n{\n\tint a, b;\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tcin >> arr[i];\n\t}\n\tcin >> M;\n\tfor (int i = 1; i <= M; i++)\n\t{\n\t\tcin >> b;\n\t\tfor (int j = 0; j < b; j++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tve[i].push_back(a);\n\t\t}\n\t}\n\tDFS(1);\n\tcout << vv[0];\n\tfor (int i = 1; i < vv.size(); i++)//循环输出\n\t{\n\t\tcout << \" \" << vv[i];\n\t}\n\tcout << endl;\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925692": {
        "problemSetProblemId": "1767420176121925692",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=2e7+10;\nconst int M=2e7;\nint n,mod;\nint prime[N];\nint mu[N];\nbool vis[N];\nint cnt;\nunordered_map<int,int>sum_mu;\nvoid init()\n{\n    mu[1]=1;\n \n    for(int i=2; i<=M; i++)\n    {\n        if(vis[i]==0)\n        {\n            prime[++cnt]=i;\n            mu[i]=-1;\n        }\n        for(int j=1; j<=cnt&&i*prime[j]<=M; j++)\n        {\n            vis[i*prime[j]]=1;\n            if(i%prime[j]==0)\n            {\n                mu[i*prime[j]]=0;\n                break;\n            }\n            mu[i*prime[j]]=-mu[i];\n        }\n    }\n    for(int i=1; i<=M; i++)\n    {\n        mu[i]+=mu[i-1];\n    }\n}\n \ninline int f1(int x)\n{\n \n    if(x<=M)\n        return mu[x];\n \n    if(sum_mu[x])\n        return sum_mu[x];\n \n    int ans=1;\n    for(int l=2,r; l<=x; l=r+1)\n    {\n \n        r=x/(x/l);\n \n        ans-=(r-l+1)*f1(x/l);\n \n    }\n \n    return sum_mu[x]=ans;\n \n}\nint qmul(int a,int b)\n{\n    return (__int128)a*b%mod;\n}\nint qmi(int a,int b)\n{\n    int res = 1;\n    while (b)\n    {\n        if (b & 1) res = qmul(res, a);\n        a = qmul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\nvoid solve()\n{\n    cin>>n>>mod;\n    int res = 1;\n    for (int l = 2, r; l <= n; l = r + 1)\n    {\n        r = n / (n / l);\n        int t = qmul(n / l, qmi(n - n / l, mod - 2));\n        res = (res - qmul(f1(r) - f1(l - 1), t) + mod) % mod;\n    }\n    cout << res << \"\\n\";\n \n}\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n \n    init();\n \n    int T;\n    T=1;\n    while(T--)\n    {\n        solve();\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925693": {
        "problemSetProblemId": "1767420176121925693",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, M = 2e6 + 5;\nint etot, head[N], ver[M], nxt[M];\nvoid add(int u, int v) {\n\tver[++etot] = v;\n\tnxt[etot] = head[u];\n\thead[u] = etot;\n}\nunordered_map<string, int> ID;\nunordered_map<int, string> findbyID;\nint n, strtot;\nint ind[N];\ntypedef pair<string, int> node;\nvector<string> ans;\nint main() {\n\tscanf(\"%d\", &n);\n\tvector<string> pre, now;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int p = 0; p < str.size(); ++p) {\n\t\t\tstring nows;\n\t\t\twhile(p < str.size() && str[p] != '.') nows += str[p++];\n\t\t\tif(ID.find(nows) == ID.end()) {\n\t\t\t\tID[nows] = ++strtot;\n\t\t\t\tfindbyID[strtot] = nows;\n\t\t\t}\n\t\t\tnow.emplace_back(nows);\n\t\t}\n\t\tif(pre.size() == now.size()) {\n\t\t\tint p = 0;\n\t\t\twhile(pre[p] == now[p]) ++p;\n\t\t\tadd(ID[pre[p]], ID[now[p]]);\n\t\t\t++ind[ID[now[p]]];\n\t\t}\n\t\tpre.swap(now);\n\t\tnow.clear();\n\t}\n\tpriority_queue<node, vector<node>, greater<node>> q;\n\tfor(auto& [str, id] : ID) {\n\t\tif(!ind[id]) q.emplace(str, id);\n\t}\n\twhile(!q.empty()) {\n\t\tans.emplace_back(q.top().first);\n\t\tint u = q.top().second;\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i]) {\n\t\t\tint v = ver[i];\n\t\t\t--ind[v];\n\t\t\tif(!ind[v]) q.emplace(findbyID[v], v);\n\t\t}\n\t}\n\tcout << ans[0];\n\tfor(int i = 1; i < ans.size(); ++i) cout << \".\" << ans[i];\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925694": {
        "problemSetProblemId": "1767420176121925694",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 300010, P = 1e9+7;\n\nvector<int> g[N];\nint sz[N],tr[N];\nint n,root;\nint sum=1,s1,s2;\n\nvoid add(int x,int y)\n{\n\tfor(int i=x;i<N;i+=(i&-i))\n\t\ttr[i]+=y;\n}\n\nint query(int x)\n{\n\tint res=0;\n\tfor(int i=x;i;i-=(i&-i))\n\t\tres+=tr[i];\n\treturn res;\n}\n\nvoid dfs(int u,int fa)\n{\n\tadd(u,1);\n\ts1=(s1+query(n)-query(u))%P;\n\t\n\tsz[u]=1;\n\tint cnt=0;\n\tfor(auto &j:g[u])\n\t{\n\t\tif(j==fa) continue;\n\t\tdfs(j,u);\n\t\tsz[u]+=sz[j];\n\t\tcnt++;\n\t} \n\t\n\tfor(int i=1;i<=cnt;i++)\n\t\tsum=(LL)sum*i%P;\n\t\n\ts2=(s2+n-query(n)-sz[u]+1)%P;\n\tadd(u,-1);\t\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&root);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n        g[a].push_back(b);\n        g[b].push_back(a); \n\t}\n\t\n\tdfs(root,-1);\n\t\n\tint ans=((LL)s1*sum+(LL)s2*sum%P*(P+1)/4)%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0; \n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925695": {
        "problemSetProblemId": "1767420176121925695",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 60;\nconst int mod = 998244353;\n\nint n,k;\nint a[maxn];\n\nint C[maxn][maxn];\nint ans;\nunordered_map <unsigned long long,int> mp[2][52],imm;\nstruct node{\n    int kk;\n    unsigned long long now;\n};\nqueue<node> q[2];\n\nbool pd(node fa,int i){\n    int dj = 0;\n    for(;i<=n;i++){\n    unsigned long long pj = (fa.now+1)&(~fa.now);\n    if((1ull<<a[i]-1)<pj) continue;\n    int pp = imm[pj];\n    dj += a[i]-pp;\n    if(dj > fa.kk) return 0;\n    fa.now += pj;\n    }\n    return 1;\n}\n\nint fast_pow(int now,int pw){\n    int ans = 1,dt = 1;\n    while(dt <= pw){\n    if(dt & pw) ans = 1ll*ans*now%mod;\n    dt<<=1;\n    now = 1ll*now*now%mod;\n    }\n    return ans;\n}\n\nint cnt = 0;\nvoid dfs(int now,unsigned long long st,int num,int way){\n    if(now > n){\n    if(num != 0) return;\n    int flag = imm.count(st+1);\n    if(!flag) return;\n    ans += way;\n    if(ans >= mod) ans -= mod;\n    }else{\n    for(int i=a[now];i>=1;i--){\n        if(a[now]-i > num) break;\n        unsigned long long bt = st|(1ull<<i-1);\n        int sz = num-(a[now]-i);\n        int tms = 1ll*way*C[num][a[now]-i]%mod;\n        int zz = (now+1)&1;\n        if(now == n){dfs(now+1,bt,sz,tms);continue;}\n        if(!pd((node){sz,bt},now+1)) continue;\n        if(mp[zz][sz].count(bt)){\n        mp[zz][sz][bt]=(mp[zz][sz][bt]+tms)%mod;\n        }else {\n        q[zz].push((node){sz,bt});\n        mp[zz][sz][bt] = tms;\n        }\n    }\n    }\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin >> n >> k;\n    for(int i=0;i<=50;i++){\n    unsigned long long u = 1ull<<i;\n    imm[u] = i+1;\n    }\n    for(int i=0;i<=k;i++){\n    C[i][0] = C[i][i] = 1;\n    for(int j=1;j<i;j++) C[i][j] = (C[i-1][j-1]+C[i-1][j])%mod;\n    }\n    for(int i=1;i<=n;i++) cin >> a[i];\n    sort(a+1,a+n+1);\n    mp[1][k][0] = 1; q[1].push((node){k,0});\n    for(int i=1;i<=n;i++){\n    for(int j=0;j<=k;j++) mp[(i&1)^1][j].clear();\n    //cnt=0;\n    while(!q[i&1].empty()){\n        //cnt++;\n        node kd = q[i&1].front(); q[i&1].pop();\n        dfs(i,kd.now,kd.kk,mp[i&1][kd.kk][kd.now]);\n    }\n    //cout<<cnt<<endl;\n    }\n    cout<<1ll*ans*fast_pow(fast_pow(n,k),mod-2)%mod<<endl;\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925696": {
        "problemSetProblemId": "1767420176121925696",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nint main(){\n  string a,b,c;\n  getline(cin,c);\n  getline(cin,a);\n  getline(cin,b);\n  int i=a.size();\n  int j=b.size();\n  int k=c.size();\n  \n  //存放结果的数组\n  int arr[20];\n  //数组的指针\n  int res=0;\n\n  int bit=0;\n  while(i>0 || j>0){\n    int x,y,z;\n    if(i<=0){\n      x=0;\n    }else{\n      x=a.at(i-1)-'0';\n    }\n    if(j<=0){\n      y=0;\n    }else{\n      y=b.at(j-1)-'0';\n    }\n    z=c.at(k-1)-'0';\n    //0代表十进制\n    if(z==0){\n      z=10;\n    }\n    //加法计算，存入\n    int num=x+y+bit;\n    arr[res]=num%z;\n    res++;\n    //进位计算\n    bit=0;\n    if(num>=z){\n      int k=num;\n      while(k>=z){\n        k/=z;\n        bit++;\n      }\n    }\n    i--;\n    j--;\n    k--;\n  }\n  if(bit!=0){\n    arr[res]=bit;\n    res++;\n  }\n  //输出处理\n  int flag=1;\n  while(res>0){\n    res--;\n    if(arr[res]==0&&flag){\n      continue;\n    }\n    cout<<arr[res];\n    flag=0;\n  }\n  if(flag){\n    cout<<0;\n  }\n\n  return 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925697": {
        "problemSetProblemId": "1767420176121925697",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n \nint main (void){\n\tint day, d, h, m;\n\t\n\tscanf(\"%d\", &day);\n\twhile(day--){\n\t\tscanf(\"%d %02d:%02d\", &d, &h, &m);\n\t\t\n\t\tif(d == 0){\n\t\t\tprintf(\"%d %02d:%02d\\n\", d, h, m);\n\t\t\tcontinue;\n\t\t}\n\t\telse if(d % 2 == 1){\n            d = d / 2 + 1;\n            m = ((h % 2) * 60 + m) / 2;\n            h = h / 2;\n            printf(\"%d %02d:%02d\\n\",d,h,m);\n        }\n        else{\n            d = d / 2;\n            h += 24;\n            m = ((h % 2) * 60 + m) / 2;\n            h = h / 2;\n            printf(\"%d %02d:%02d\\n\",d,h,m);\n        }\n\t}\n\t\t\n\treturn 0;\n} "
        },
        "problemId": "0"
    },
    "1767420176121925698": {
        "problemSetProblemId": "1767420176121925698",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main() \n{\n \n\tint a, b;\n\tint t, flag = 0;\n\tscanf(\"%d%d\", &a, &b);\n    int S=a*b;\n\tif (S == 0) printf(\"0\");\n\twhile (S != 0)\n\t{\n\t\tt = S % 10;\n\t\tS /= 10;\n\t\tif (t != 0 || flag == 1)\n\t\t{\n\t\t\tflag = 1;\n\t\t\tprintf(\"%d\", t);\n\t\t}\n\t}\n \n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925699": {
        "problemSetProblemId": "1767420176121925699",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint pd(char x){\n    if(x=='A'){\n        return 1;\n    }\n    if(x=='B'){\n        return 2;\n    }\n    if(x=='C'){\n        return 3;\n    }\n    if(x=='D'){\n        return 4;\n    }\n}\nint main(){\n    int n;\n    string s;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<4;j++){\n            cin>>s;\n            if(s[2]=='T'){\n                cout<<pd(s[0]);\n            }\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925700": {
        "problemSetProblemId": "1767420176121925700",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n    int a,b;//a、b分别是纸牌的初始数量和魔术师推送的次数\n    scanf(\"%d %d\",&a,&b);\n    int m=b;\n    if(b%2)\n        b=(b-1)/2;\n    else\n        b=b/2;//变成纸牌的次数\n    while(b>0)\n    {\n        a=a*2;\n        b--;\n    }\n    if(m%2)//判断是纸牌还是硬币\n        printf(\"1 %d\\n\",a);\n    else\n        printf(\"0 %d\\n\",a);\n           return 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925701": {
        "problemSetProblemId": "1767420176121925701",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    int i,j,a[m],b[m];\n    for(i=0;i<m;i++){\n     scanf(\"%d\",&a[i]);//a[]表示每道题的分值\n    }\n    for(i=0;i<m;i++)\n        scanf(\"%d\",&b[i]);//b[]表示正确答案\n    int sum=0,k;\n    for(k=0;k<n;k++){\n    for(i=0;i<m;i++){\n        scanf(\"%d\",&j);\n        if(j==b[i])sum+=a[i];\n    }\n    printf(\"%d\\n\",sum);\n    sum=0;}\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925702": {
        "problemSetProblemId": "1767420176121925702",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\n \nint main(void)\n{\n    int i,n,f1,f2,f3; //f1标记数字，f2标记字母，f3标记其他字符\n    char c;\n    scanf(\"%d%*c\",&n);\n    for (;n>0;n--)\n    {\n        i=0;f1=0;f2=0;f3=0;\n        do\n        {\n            scanf(\"%c\",&c);i++;\n            if (c>='0' && c<='9') f1=1;\n            else if ((c>='a' && c<='z') || (c>='A' && c<='Z')) f2=1;\n            else if (!(c=='.'|| c=='\\n')) f3=1;\n        }while(c!='\\n');\n        if (i-1<6) printf(\"Your password is tai duan le.\\n\");\n        else if (f3==1) printf(\"Your password is tai luan le.\\n\");\n        else if (f1==0) printf(\"Your password needs shu zi.\\n\");\n        else if (f2==0) printf(\"Your password needs zi mu.\\n\");\n        else printf(\"Your password is wan mei.\\n\");\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925703": {
        "problemSetProblemId": "1767420176121925703",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n#include<string>\n#include<cmath>\nusing namespace std;\nbool isPrime(int a){\n\tif (a == 0 || a == 1)\n\t\treturn false;\n\tfor (int i = 2; i <=sqrt(a); i++){\n\t\tif ((a % i) == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main(){\n\tint l, k, temp;\n\tstring n,s;\n\tbool flag = false;\n\tcin >> l >> k >> n;\n\t//测试点4：因为s.size()返回的是unsigned int类型的数，\n\t//当l<k本来应该是复数，但是用s.size()-k得到了极大正数，所以循环继续\n\t//测试点2,5，不要写成i<k，会到不了最后一位\n\tfor (int i = 0; i <=l-k ; i++){\n\t\ts = n.substr(i, k);\n\t\ttemp = stoi(s);\n\t\tif (isPrime(temp)){\n\t\t\tcout << s;\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!flag)\n\t\tcout << \"404\";\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925704": {
        "problemSetProblemId": "1767420176121925704",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\nusing namespace std;\nint main(void){\n\tint a,b;\n\tcin>>a>>b; \n\tdouble x =(double) ( (double) a / (double )b ) ;\n\tprintf(\"%d/%.1lf=%d\\n\",a,x,b);\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925705": {
        "problemSetProblemId": "1767420176121925705",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    if (0 <= n && n <= 100)\n    {\n        if (n >= 90)\n        {\n            printf(\"gong xi ni kao le %d fen!\", n);\n        }\n        else\n        {\n            printf(\"kao le %d fen bie xie qi!\", n);\n        }\n        return 0;\n    }\n }"
        },
        "problemId": "0"
    },
    "1767420176121925706": {
        "problemSetProblemId": "1767420176121925706",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<math.h>\n#include<stdio.h>\nint main(){\n\tint n,x,y,z;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\t(x*x+y*y+z*z)==(3*x*y*z)?printf(\"Yes\\n\"):printf(\"No\\n\");\n\t}\n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925707": {
        "problemSetProblemId": "1767420176121925707",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n\tint n,m,i,j,temp,sum=0,a,b[100001],k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tfor(j=2;j<10;j++)\n\t\t{\n\t\t\tsum=0;\n\t\t\ttemp=m*j;               //输入的数去分别乘以2、3、4、5、6、7、8、9 \n\t\t\twhile(temp!=0)          //temp为0是终止循环 \n\t\t\t{\n\t\t\t\ta=temp%10;          //取个位   如352%10=2 \n\t\t\t\ttemp=temp/10;       //去掉个位  如352/10=35   \n\t\t\t\tsum=sum+a;          //取得每一位 相加求和 \n\t\t\t}\n\t\t\tb[sum]++;              //将和sum 以下标存进b数组中         \n\t\t}\n\t\tif(b[sum]==8)              //如果b数组以sum为下标的值为8 就说明符合题意 为啥是8 因为分别乘以2、3、4、5、6、7、8、9   是8次 \n\t\t\tprintf(\"%d\\n\",sum);\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\tfor(j=0;j<100001;j++)      //将b数组全部置为0 再进行下一次 这里不要用 b[100001]={0} \n\t\t\tb[j]=0;\n\t}\n\treturn 0;\t\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925708": {
        "problemSetProblemId": "1767420176121925708",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include\"stdio.h\"\nint main(){\n\tint n,x,y,a[10000],b[1000]={0},flag=0,flag1=0;\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d-%d %d\",&x,&y,&a[i]);\n\t\tb[x]=b[x]+a[i];\n\t}\n\tfor(i=0;i<1000;i++){\n\t\tif(flag<b[i]){\n\t\t\tflag=b[i];\n\t\t\tflag1=i;\n\t\t}\n\t}\n\tprintf(\"%d %d\",flag1,flag);\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925709": {
        "problemSetProblemId": "1767420176121925709",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    string s;\n    cin>>s;\n    cout<<\"print(\"<<s<<\")\";\n\n}"
        },
        "problemId": "0"
    },
    "1767420176121925710": {
        "problemSetProblemId": "1767420176121925710",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n    int n,m;\n    scanf(\"%d %d\",&n,&m);\n    printf(\"%d\",n+m-1);\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925711": {
        "problemSetProblemId": "1767420176121925711",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin>>n;\n\tgetchar();\n\twhile(n--)\n\t{\n\t\tint flag=1;\n\t\tstring a;\n\t\tgetline(cin,a);\n\t\tfor(int i = 0;i < a.size();i ++ )\n\t\t{\n\t\t\tif(a[i]>='b'&&a[i]<='z')\n\t\t\t{\n\t\t\t\tif(a[i+1]==a[i]-32||a[i+1]==a[i]-1||a[i+1]=='\\0')continue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(a[i]=='a')\n\t\t\t{\n\t\t\t\tif(a[i+1]==a[i]-32||a[i+1]=='\\0')continue;\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a[i]>='A'&&a[i]<='Y')\n\t\t\t{\n\t\t\t\tif(a[i+1]==a[i]+32||a[i+1]==a[i]+1||a[i+1]=='\\0')continue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(a[i]=='Z')\n\t\t\t{\n\t\t\t\tif(a[i+1]==a[i]+32||a[i+1]=='\\0')continue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag==1)cout<<\"Y\"<<endl;\n\t\telse cout<<\"N\"<<endl;\n\t}\n\treturn 0; \n}"
        },
        "problemId": "0"
    },
    "1767420176121925712": {
        "problemSetProblemId": "1767420176121925712",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint main()\n{\n\tint n,m,k,i,j,p=1,a[100][100],sum=0;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(i=0;i<n;i++)\n\t\tfor(j=0;j<n;j++)\n\t\t\tscanf(\"%d\",&a[i][j]);\t\t\n\tfor(i=n-1;i>=0;i--)    //从最后一行开始 \n\t{\n\t\tp=1;\n\t\tfor(j=0;j<n;j++)\n\t\t{\n\t\t\tif((j+1)%2==0)   //偶数列 \n\t\t\t{\n\t\t\t\tif(i-p>=0)            //判断 a数组中 以i-p为下标的元素是否存在 \n\t\t\t\t\ta[i][j]=a[i-p][j];      //存在 向下移p个单位 \n\t\t\t\telse                    //不存在 添k \n\t\t\t\t\ta[i][j]=k;\n\t\t\t\tp++;          //移动的单位是1、2...p 接着 1、2...p\n\t\t\t\tif((p>m))     //如果数组大 或者m的值小 p接着从1开始 \n\t\t\t\t\tp=1; \n\t\t\t}\t\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)            //求每一列的和 \n\t{\n\t\tfor(j=0;j<n;j++)  \n\t\t\tsum+=a[i][j];\n\t\tif(i<n-1)              //控制空格 \n\t\t\tprintf(\"%d \",sum);\n\t\telse\n\t\t\tprintf(\"%d\",sum);\n\t\tsum=0;\n\t}\n\treturn 0;\t\n} \n"
        },
        "problemId": "0"
    },
    "1767420176121925713": {
        "problemSetProblemId": "1767420176121925713",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\n#include<math.h>\nint sushu(int i)          //求素数函数       \n{\n\tint flag1=0;\n\tif(i>=2)\n\t{\n\t\tfor(int j=2;j<=sqrt(i);j++)\n\t\t{\n\t\t\tif(i%j==0)\n\t\t\t{\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\treturn 1;\n\treturn flag1;\n}\nint main()\n{\n\tint n,m,i,j,t,a[10000],flag1=0,k=0,count=0;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=n;i<=m;i++)\n\t{\n\t\tflag1=sushu(i);\n\t\tif(flag1==0)\n\t\t{\n\t\t\ta[k]=i;\n\t\t\tk++;\n\t\t}\n\t}\t\n\tfor(i=0;i<=k;i++)\n\t{\n\t\tfor(j=i;j<=k;j++)\n\t\t{\n\t\t\tfor(t=j;t<=k;t++)\n\t\t\t{\n\t\t\t\t\tif((sushu(a[i]*a[j]+a[t])==0)&&(sushu(a[j]*a[t]+a[i])==0)&&(sushu(a[t]*a[i]+a[j])==0))\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",count);\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420176121925714": {
        "problemSetProblemId": "1767420176121925714",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<stdio.h>\n \nint m,n,k;\nint stack[1007];       //栈 \nint top=0;             //栈顶下标 \nint index1=1,index2=1;     //index1来表示1-n的数字 ，index2来表示数组b的下标 \nint b[1007];           //存放出栈序列 \n \nint main()\n{\n    scanf(\"%d%d%d\",&m,&n,&k);\n    while(k--)\n    {\n    \tint flag=1; \n    \tindex1=1;index2=1;\n    \ttop=0; \n    \tint i;\n    \tfor(i=1;i<=n;i++)\n    \t  scanf(\"%d\",&b[i]);\n    \twhile(1)\n    \t{\n    \t\t//判断给出的出栈序列如果和1到n增长顺序相同，那就是入栈一个元素，然后立即出栈。 \n    \t\tif(index1==b[index2])\n    \t\t{\n    \t\t\tindex1++;\n    \t\t\tindex2++;\n\t\t\t}\n\t\t\t//判断如果栈中有元素，然后栈顶元素也与此时的出栈序列元素相同，那么就继续出栈来判断 \n\t\t\telse if(top!=0&&stack[top-1]==b[index2])\n\t\t\t{\n\t\t\t\ttop--;\n\t\t\t\tindex2++; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(index1>n)break;  //已经判断结束，就跳出循环 \n\t\t\t\tstack[top]=index1;  //元素入栈 \n\t\t\t\ttop++;\n\t\t\t\tindex1++;\n\t\t\t\tif(top>=m) //\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag==0||top!=0)printf(\"NO\\n\");\n\t\telse printf(\"YES\\n\");\n\t}\n    \n\treturn 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925715": {
        "problemSetProblemId": "1767420176121925715",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<iostream>\n \nusing namespace std;\nconst int N = 1e3 + 10;\nint n;\nint l[N],r[N],w[N],idx;\nint ans[N],maxn;\n \n//l、r数组中存放的是i的子节点的在输入中的下标\n//dfs按下标逐个遍历\n//每遍历一层且有子节点，那就让ans++\n \nvoid build(int &u ,int x){\n\tif(u == 0){\n\t\tu = ++ idx;\n\t\tw[u] = x;\n\t\treturn;\n\t}\n\tif(x <= w[u]) build(l[u],x);\n\telse build(r[u],x);\n}\n \nvoid dfs(int u , int d){\n\tif(!u) return;\n\tans[d] ++;\n\tmaxn = max(maxn,d);\n\tdfs(l[u],d+1);\n\tdfs(r[u],d+1);\n}\n \nint main(){\n\tcin >> n;\n\tint root = 0;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tint x;\n\t\tcin >> x;\n\t\tbuild(root,x);\n\t}\n\tdfs(root,0);\n\tprintf(\"%d\",ans[maxn-1] + ans[maxn]);\n\t\n}"
        },
        "problemId": "0"
    },
    "1767420176121925716": {
        "problemSetProblemId": "1767420176121925716",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n \nusing namespace std;\ntypedef long long ll;\nll n, p, nums[200010], res;\nint main() {\n   \n    cin >> n >> p;\n    for (int i = 0; i < n; i++) \n        cin >> nums[i];\n \n    // 对其他国家的实力值进行排序\n    sort(nums, nums + n);\n \n    for (int i = 0; i < n; i++) {\n        // 使用二分查找找到满足条件的组合数量\n        // upper_bound 找到第一个大于 fabs(p - nums[i]) 的位置\n        // lower_bound 找到第一个大于等于 p + nums[i] 的位置\n        int l = upper_bound(nums + i + 1, nums + n, fabs(p - nums[i])) - nums;\n        int r = lower_bound(nums + i + 1, nums + n, p + nums[i]) - nums;\n        res += (r - l);\n    }\n \n    cout << res << endl;\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925717": {
        "problemSetProblemId": "1767420176121925717",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\nconst int MAXN = 100010;\nmap<string, int> mp;\nstring str[MAXN];\n\nint main(void)\n{\n    int n, s;\n    cin >> n >> s;\n    for ( int i = 0; i < n; i ++ )\n        cin >> str[i];\n    for ( int i = 1; i <= n / s; i ++ )\n        for ( int j = 1; j <= s; j ++ )\n            cin >> mp[str[i * s - j]];\n    int k;\n    cin >> k;\n    string num;\n    while ( k -- ) {\n        cin >> num;\n// count是STL库自带的函数，计算容器中值出现的次数\n        if ( mp.count(num) ) cout << mp[num] << endl;\n        else cout << \"Wrong Number\\n\";\n    }\n    \n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420176121925718": {
        "problemSetProblemId": "1767420176121925718",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 21;\nint l[N], r[N], in[N], post[N];//l,r分别为左右视图数组，in中序，post后序\nint z=0, y=0 ,n, m;            //z左，y右\ntypedef struct Node* pnode;\nstruct Node {\n\tint data;   //数据\n\tint h;      //高度\n\tpnode l, r;\n};\ntypedef pnode Tree;\n//il,ir分别为中序遍历起点和终点，pl,pr分别为后序遍历起点和终点\nTree create(int il, int ir, int pl, int pr, int high) {\n\tTree t;\n\tif (pl > pr) return NULL;  //此时对应子树为空，返回NULL\n\tt = (pnode)malloc(sizeof(struct Node));\n\tt->data = post[pr];        //后序遍历每一段最后一个就是根节点\n\tt->h = high;\n\tint i = il;\n\twhile(in[i] != post[pr]) i++;  //用i找到根节点对应的中序遍历中的位置\n\tt->l = create(il, i - 1, pl, pl + i - 1 - il, high + 1);\n\tt->r = create(i + 1, ir, pl + i - il, pr - 1, high + 1);\n\treturn t;   //递归建树\n}\n \nvoid Bianli(Tree t) {\n\tpnode p, pre=NULL;\n\tqueue<Tree> q;\n\tif (t == NULL) return;\n\tq.push(t);\n\twhile (!q.empty()) {\n\t\t\n\t\tp = q.front();\n\t\tq.pop();\n\t\tif (pre == NULL) l[z++] = p->data;  //对头节点的处理\n\t\telse {\n\t\t\tif (p->h != pre->h) {\n\t\t\t\tl[z++] = p->data;\n\t\t\t\tr[y++] = pre->data;\n\t\t\t}\n\t\t}\n\t\tpre = p;\n\t\tif (p->l) q.push(p->l);\n\t\tif (p->r) q.push(p->r);\n\t}\n\tr[y++] = p->data;      //对最后一个右视图的处理\n}\n \nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> in[i];\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> post[i];\n\tTree t = create(0, n - 1, 0, n - 1, 0);\n\tBianli(t);\n\tcout << \"R:\";\n\tfor (int i = 0; i < z; i++)\n\t\tcout << \" \" << r[i];\n\tcout << endl << \"L:\";\n\tfor (int i = 0; i < y; i++)\n\t\tcout << \" \" << l[i];\n\tcout << endl;\n\treturn 0;\n\t\n}"
        },
        "problemId": "0"
    },
    "1767420176121925719": {
        "problemSetProblemId": "1767420176121925719",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\nconst ll N = 2e5 + 10;\nll n, m;\nll l, flag;\nll a[N];\nll honest[N];//每个人是否为狼人：1为好人，-1为狼人\nvector<ll> ans, ve;//分别为临时假设为狼人的人，和最终是狼人的人\n \nvoid dfs(ll idx, ll num) {//idx代表当前遍历的下标，num为当前狼人的数量\n    if (num == m && flag == 0) {//如果狼人数量有m个时候，并且没有找到答案\n        ve.push_back(idx);//假设我们idx这个人为狼人\n        honest[idx] = -1;//假设这个狼人\n        ll cnt = 0;//存狼人说谎的人数\n        ll lie = 0;//存说谎的人\n        for (ll i = 1; i <= n; i++) {\n            if (a[i] * honest[abs(a[i])] < 0) {//如果描述的这个个人的身份和当前人假设的身份不同，说明这个人说谎了\n                lie++;//将说谎的人存进去\n                if (honest[i] == -1) cnt++;//如果这个人是狼人并且说谎了\n            }\n        }\n        if (lie == l && cnt >= 1 && cnt < m) {//当前说谎人数满足l，并且并不是所以狼人在说谎\n            ans = ve;//将当前狼人赋给ans\n            flag = 1;//找到了答案，标记\n        }\n        honest[idx] = 1;//将狼人赋回好人\n        ve.pop_back();//删掉这个人\n    }\n    if (num > m || idx < 1 || flag == 1) return;//找到过答案或者超过边界退出\n    ve.push_back(idx);//假设idx为狼人\n    honest[idx] = -1;//将idx标为狼人\n    dfs(idx - 1, num + 1);//狼人数量+1\n    honest[idx] = 1;//将idx标为好人\n    ve.pop_back();//删掉这个人\n    dfs(idx - 1, num);//假设这个人是好人\n}\n \nint main() {\n    cin >> n >> m >> l;\n    for (ll i = 1; i <= n; i++) {\n        cin >> a[i];\n        honest[i] = 1;//假设每个人都说真话\n    }\n    dfs(n, 1);//因为要找到最大的那组答案，所以倒着遍历下标\n    if (ans.size() == 0)cout << \"No Solution\" << endl;//如果没有将答案赋值给ans过即没有答案\n    else {\n        for (ll i = 0; i < ans.size(); i++) {//输出\n            if (i != 0) cout << \" \";\n            cout << ans[i];\n        }\n    }\n}"
        },
        "problemId": "0"
    },
    "1767420176121925720": {
        "problemSetProblemId": "1767420176121925720",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\n \nusing namespace std;\n \nconst int N = 1e3 + 10, M = 365 * 24 * 60 + 10;\n \nint n, m;\nint v[N], w[N];\nint dp[M];\n \nint gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a;\n}\n \nint main() {\n    cin >> n >> m;\n    cin >> v[0];\n    int yuanzi = v[0];\n    for (int i = 1; i < n; i ++ ) {\n        cin >> v[i];\n        yuanzi = gcd(v[i], yuanzi);\n    }\n    for (int i = 0; i < n; i ++ ) cin >> w[i];\n    for (int i = 0; i < n; i ++ ) {\n        int cnt = 0;\n        for (int j = m; j >= v[i]; j -= yuanzi ) {\n            if (dp[j - v[i]] + w[i] > dp[j]) dp[j] = dp[j - v[i]] + w[i];\n            else cnt ++;\n            if (cnt == 10) break;\n        }\n    }\n    cout << dp[m] << endl;\n}"
        },
        "problemId": "0"
    },
    "1767420299136679936": {
        "problemSetProblemId": "1767420299136679936",
        "programmingSubmissionDetail": {
            "compiler": "PHP",
            "program": "Good code is its own best documentation."
        },
        "problemId": "0"
    },
    "1767420299136679937": {
        "problemSetProblemId": "1767420299136679937",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint main() {\n    int a, b;\n    cin >> a >> b;\n    cout << a + b - 16 << '\\n' << a + b - 3 << '\\n' << a + b - 1 << '\\n' << a + b;\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420299136679938": {
        "problemSetProblemId": "1767420299136679938",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n,m,k;\n\tstring x;\n\tcin>>n>>x>>m>>k;\n\tif(k==n) cout<<\"mei you mai \"<<x<<\" de\";\n\telse if(k==m) cout<<\"kan dao le mai \"<<x<<\" de\";\n\telse cout<<\"wang le zhao mai \"<<x<<\" de\";\n\t\n\treturn 0;\n}\n"
        },
        "problemId": "0"
    },
    "1767420299136679939": {
        "problemSetProblemId": "1767420299136679939",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint main() {\n    int N, A, B, C;\n    cin >> N;\n    while(N--) {\n        cin >> A >> B >> C;\n        if (C == A * B) cout << \"Lv Yan\\n\";\n        else if (C == A + B) cout << \"Tu Dou\\n\";\n        else cout << \"zhe du shi sha ya!\\n\";\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420299136679940": {
        "problemSetProblemId": "1767420299136679940",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include <iostream>\nusing namespace std;\nint Hat[105], Guess, Right, Wrong, N, K;\nint main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) cin >> Hat[i];\n    cin >> K;\n    while(K--) {\n        Right = Wrong = 0;\n        for (int i = 1; i <= N; i++) {\n            cin >> Guess;\n            if (Guess && Guess == Hat[i]) Right = 1;\n            else if (Guess && Guess != Hat[i]) Wrong = 1;\n        }\n        if (Wrong || !Right) cout << \"Ai Ya\\n\";\n        else cout << \"Da Jiang!!!\\n\";\n    }\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420299136679941": {
        "problemSetProblemId": "1767420299136679941",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<string.h>\nvoid dltblack(char arr[], int sz)//去除多余空格.\n{\n    int i = 0, j = 0;\n    for (i = 0; i < sz; i++)\n    {\n        if (arr[i] == ' ')\n        {\n            for (j = i; j < sz; j++)\n            {\n                arr[j] = arr[j + 1];\n            }\n            i--;\n        }\n    }\n}\nint Iscv(char s[], char frt[], char bhd[])//判断是否能够插入以及得出插入位置。\n{\n    int i = 0, point = 1, n = 0,t = 0;\n    for (i = 0; i < strlen(s); i++)\n    {\n        int j = 0;\n        int k = 0;\n        point = 1;\n        for (j = i, n = 0; n < strlen(frt); j++, n++)\n        {\n            if (s[j] != frt[n])\n            {\n                point = 0;\n                break;\n            }\n        }\n        t = j;\n        for (n = 0; n < strlen(bhd); n++, j++)\n        {\n            if (s[j] != bhd[n])\n            {\n                point = 0;\n                break;\n            }\n        }\n        if (point == 1)\n        {\n            return t;\n        }\n    }\n    return 0;\n}\nvoid cv(char s[], char ch[], int count)//实现粘贴。\n{\n    char tmp[201];\n    int i = 0, j = 0, c = 0;\n    if (count == 0)//如果count=0表示中间没有可插入位置则直接插入到最后。\n    {\n        strcat(s, ch);\n    }\n    else\n    {\n        for (i = count, c = 0; i <=strlen(s); i++, c++)//由于插入时是赋值会盖掉插入位置后的元素，需要先将这些元素保存在临时数组中。\n        {\n            tmp[c] = s[i];\n        }\n        for (i = count, c = 0; c <= strlen(ch); c++, i++)//插入\n        {\n            s[i] = ch[c];\n        }\n        strcat(s, tmp);//插入完成后把后面的那些的元素插入进来\n    }\n}\nint main()\n{\n    int n = 0, f, b;//n为控制操作次数，f和b为剪切位置。\n    char s[201], frt[10], bhd[10], ch[201];//s表示输入的字符串，frt和bhd分别表示插入前后字符串。\n    gets(s);//ch表示剪切的内容\n    scanf(\"%d\", &n);//按照题意输入\n    getchar();\n    for (int t = 0; t < n; t++)\n    {\n        scanf(\"%d%d %s %s\", &f, &b, &frt, &bhd);//按照题意输入\n        int i = 0, j = 0;\n        for (i = f - 1; i <= b - 1; i++, j++)//将s中剪切的内容存到ch中，并把剪切的内容变成空格\n        {\n            ch[j] = s[i];\n            s[i] = ' ';\n        }\n        ch[j] = '\\0';\n        dltblack(s, strlen(s));//删除空格。\n        int count = Iscv(s, frt, bhd);//函数判断两个字符中间是否可插入并得到插入位置。\n        cv(s, ch, count);//复制函数将剪切的内容插入到指定位置.\n    }\n    printf(\"%s\", s);//打印操作完后的字符串。\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420299136679942": {
        "problemSetProblemId": "1767420299136679942",
        "programmingSubmissionDetail": {
            "compiler": "GXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef struct node{\n\tint x,y;\n\tint sum;\n}node;\nbool cmp(node x,node y){\n\treturn x.sum<y.sum;\n\t\n}\nint main(){\n    int x,y,sum;\n    cin>>x>>y>>sum;\n    vector<node> a;\n    \n    for(int i = 1;i<sum;i++){\n        //分配男生\n        if(x%i==0&&y%(sum-i)==0&&x/i!=1&&y/(sum-i)!=1)\n        {\n\t\t\tnode temp;\n\t\t\ttemp.x = i;\n\t\t\ttemp.y = (sum-i);\n\t\t\ttemp.sum = (abs(x/i-y/(sum-i)));\n\t\t\ta.push_back(temp);\n\t\t\t\n\t\t}\n        \n           \n           \n    }\n\tif(!a.empty()) {\n\t\tsort(a.begin(),a.end(),cmp);\n\t\tcout<<a[0].x<<\" \"<<a[0].y;//最优情况输出\n\t}\n\t        else cout<<\"No Solution\";    \n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420299136679943": {
        "problemSetProblemId": "1767420299136679943",
        "programmingSubmissionDetail": {
            "compiler": "GCC",
            "program": "#include<stdio.h>\nint a,b;\n    int N;\nint count(int x)\n{\n    int q=0;\n        while(x>0)\n    {\n        q=q+(x%10);\n        x=x/10;\n    }\n    return q;\n    \n}\nvoid sum()\n{\n    scanf(\"%d%d\",&a,&b);\n    int m1,m2; \n    m1=count(a);\n    m2=count(b);\n    if(a%m2==0&&b%m1==0)\n    {\n        if (a>b) printf (\"A\\n\");\n        else printf (\"B\\n\");\n    }else if (a%m2==0) printf (\"A\\n\");\n    else if (b%m1==0) printf(\"B\\n\");\n    else {\n        if (a>b) printf (\"A\\n\");\n        else printf (\"B\\n\");\n    }\n}\nint main()\n{\n    scanf(\"%d\",&N);\n    while(N--)\n    sum();\n    return 0;\n}"
        },
        "problemId": "0"
    },
    "1767420299136679944": {
        "problemSetProblemId": "1767420299136679944",
        "programmingSubmissionDetail": {
            "compiler": "CLANGXX",
            "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    stack<int>a,b;\n    int n,c,bts=0,btc=0;\n    cin>>n;\n    while(n--){\n        cin>>c;\n        if(a.empty()||c<a.top()){\n            a.push(c);\n        }else{\n            if(b.empty()||c>b.top()){\n                b.push(c);\n            }else{\n                bts++;\n                if(btc<a.size()){\n                    btc=a.size();\n                }\n                while(!a.empty()){\n                    a.pop();\n                }\n                while((!b.empty())&&b.top()>c){\n                    a.push(b.top());\n                    b.pop();\n                }\n                a.push(c);\n            }\n        }\n    }\n    if(!a.empty()){\n        bts++;\n        if(btc<a.size()){\n            btc=a.size();\n        }\n    }\n    if(!b.empty()){\n        bts++;\n        if(btc<b.size()){\n            btc=b.size();\n        }\n    }\n    cout<<bts<<\" \"<<btc;\n}"
        },
        "problemId": "0"
    }
}